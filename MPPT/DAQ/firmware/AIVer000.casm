;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

/*********************************************************************
 *                  Flowcode CAL String File
 *
 * File: PIC_CAL_String.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 010911 | BR | Created
 * 150911 | JW | Added v5 string functions
 * 270212 | BR | Fixed an issue with ToUpper where the 1st character was being returned as null
 * 120312 | BR | Fixed an issue with some of the float functions not using CAL functions
 * 250912 | BR | Fixed an issue with the ToString function which caused the contents of the input variable to be cleared to 0
 * 091213 | LM | Flowcode now passes FCV_PRECISION
 * 230114 | LM | Updated string compare (length params are buffer size, not character count)
 * 050314 | LM | Allow use of 32 bit mantissa in Float to String function
 * 060314 | LM | Default to using 32 bit
 * 070414 | LM | String functions to return string pointer, not length (FC6 requirement)
 */


// Useful call for finding the length of an (uncorrupted) string
#define FCI_GETLENGTH__x(str, max, idx)         for (idx = 0; idx < max; idx++) if (str[idx] == 0) break
#define FCI_STRMOV__x(str, max, dst, dlen, ix)  for (ix = 0; ix < (max) && ix < (dlen) && str[ix] != '\0'; ix++) dst[ix] = str[ix]
#define FCI_CONCATENATE(s0, l0, s1, l1, sd, ld) FCI_SHEAD(s0, l0, s1, l1, sd, ld)


#ifndef MX_USES_UINT32
	#define MX_USES_UINT32 1
#endif
#ifndef MX_USES_SINT32
	#define MX_USES_SINT32 1
#endif


#if (MX_USES_UINT32 || MX_USES_SINT32)
	#define MX_STRF_LONG
	#define MX_ULONG MX_UINT32
	#define MX_SLONG MX_SINT32
#else
	#define MX_ULONG MX_UINT16
	#define MX_SLONG MX_SINT16
#endif



#define FCI_ITOS8(value, text, length)		FCI_TOSTRS16(value, text, length)
#define FCI_ITOS16(value, text, length)  	FCI_TOSTRS16(value, text, length)
#define FCI_ITOS32(value, text, length)		FCI_TOSTRS32(value, text, length)

#define FCI_UTOS8(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS16(value, text, length)		FCI_TOSTRU16(value, text, length)
#define FCI_UTOS32(value, text, length)		FCI_TOSTRU32(value, text, length)
// FCV_PRECISION
#define FCI_FTOS32(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);
#define FCI_FTOS64(value, precision, text, length)		FCI_FLOAT_TO_STRING(value, precision, text, length);

#define FCI_STOF(text)						FCI_STRING_TO_FLOAT(text, 15);
#define FCI_STOI(text)						FCI_STRING_TO_INT(text, 15);
#define FCI_STOU(text)						FCI_STRING_TO_INT(text, 15);


/*
#define FCI_FTOS16(value, text, length)
#define FCI_FTOS64(value, text, length)

#define FCI_STOF(text)  FCI_STRING_TO_FLOAT(text, )
#define FCI_STOI(text)	FCI_STRING_TO_INT
#define FCI_STOU(text)
*/






//String function definitions
MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos);
MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len);
MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);
MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len);

MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);

MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len);


void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase);
MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String);
MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String);
MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String);
MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String);

// Functions for contatenation
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len);
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len);



MX_UINT8 FCI_GETCHAR(MX_STRING sStr1, MX_UINT8 iStr1_len, MX_UINT8 iPos)
{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);

	if(iPos < tmp)
		return sStr1[iPos];
	return '\0';
}

MX_UINT8 FCI_GETLENGTH(MX_STRING sStr1, MX_UINT8 iStr1_len)

{
	MX_UINT8 tmp;
	FCI_GETLENGTH__x(sStr1, iStr1_len, tmp);
0ED6  6BFE      	CLRF FCI_GETLEN_0003D_1_tmp, 1
0ED8            label128
0ED8  51FD      	MOVF FCI_GETLEN_0003D_arg_iStr1_len, W, 1
0EDA  61FE      	CPFSLT FCI_GETLEN_0003D_1_tmp, 1
0EDC  D009      	BRA	label129
0EDE  51FC      	MOVF FCI_GETLEN_0003D_arg_sStr1+D'1', W, 1
0EE0  6EEA      	MOVWF FSR0H
0EE2  51FB      	MOVF FCI_GETLEN_0003D_arg_sStr1, W, 1
0EE4  25FE      	ADDWF FCI_GETLEN_0003D_1_tmp, W, 1
0EE6  6EE9      	MOVWF FSR0L
0EE8  52EF      	MOVF INDF0, F
0EEA  E002      	BZ	label129
0EEC  2BFE      	INCF FCI_GETLEN_0003D_1_tmp, F, 1
0EEE  D7F4      	BRA	label128
0EF0            label129

	return (tmp);
0EF0  51FE      	MOVF FCI_GETLEN_0003D_1_tmp, W, 1
0EF2  6FFF      	MOVWF CompTempVarRet1856, 1

}
0EF4  0012      	RETURN


MX_STRING FCI_MIDSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iStart, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iStart >= idx)
	{
		*sDst = '\0';						//starting position is beyond string length, so return a null string
	}
	else
	{
		if ((iStart + iCount) >= idx)		//Make sure the required length is not too big
			iCount = idx - iStart;
		if (iCount > (iDst_len))			//make sure the required length is not too big
			iCount = (iDst_len);

		sSrc += iStart;						//Move to the correct place in the source string

		for (idx = 0; idx < iCount; idx++)	//Copy the contents of the source string
		{
			*sDst = *sSrc;
			sDst++;
			sSrc++;
		}
		if (idx < iDst_len)						//add terminating null (if we can)
			*sDst = '\0';
	}
	return (sDst);
}

MX_STRING FCI_LEFTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	if (iCount > (iDst_len))			//make sure the required length is not too big
		iCount = (iDst_len);

	for (idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}

MX_STRING FCI_RIGHTSTRING(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_UINT8 iCount, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return sDst;
	MX_UINT8 idx;
	MX_UINT8 delta;

	FCI_GETLENGTH__x(sSrc, iSrc_len, idx);	//find the length of the source string

	if (iCount > idx)						//make sure the required length is not too big
		iCount = idx;
	delta = idx - iCount;					//get the offset
	if (iCount > (iDst_len))				//make sure the required length is not too big
		iCount = (iDst_len);
	sSrc += delta;							//Move to the correct place in the source string

	for(idx = 0; idx < iCount; idx++)		//copy the required MX_UINT8acters
	{
		*sDst = *sSrc;
		sDst++;
		sSrc++;
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		*sDst = '\0';
	return (sDst);
}


MX_UINT8 FCI_TOSTRS16(MX_SINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRS32(MX_SINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_SINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU16(MX_UINT16 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT16 iSrc = iSrc1;
	MX_UINT16 top = 10000; 		// Maximum power of 10 less than 65536
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}


MX_UINT8 FCI_TOSTRU32(MX_UINT32 iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8  tmp1;
	MX_UINT32 iSrc = iSrc1;
	MX_UINT32 top = 1000000000; 	// Maximum power of 10 less than 4294967296
	MX_UINT8  idx = 0;

	if (iDst_len == 0) return 0;

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		if (((unsigned long)iSrc >= top) || (tmp1))
		{
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (idx);
}







MX_STRING FCI_TOSTRING(MX_SLONG iSrc1, MX_STRING sDst, MX_UINT8 iDst_len)
{
	MX_UINT8 tmp1;

	MX_SLONG iSrc = iSrc1;

	#ifdef MX_STRF_LONG
		unsigned long top = 1000000000; 	// Maximum power of 10 less than 4294967296
	#else
		unsigned short top = 10000; 		// Maximum power of 10 less than 65536
	#endif

	MX_UINT8 idx = 0;

	if (iDst_len == 0) return sDst;

	//copy source 1 into destination:
	//minus sign
	if (iSrc < 0)
	{
		sDst[0] = '-';
		idx++;
		iSrc = -iSrc;
	}

	tmp1 = 0;    // Nothing added yet
	if (iSrc == 0) // Force showing zero
	{
		tmp1 = 1;
		top = 1;
	}
	while (( idx < iDst_len) && (top > 0))
	{
		#ifdef MX_STRF_LONG
		if (((unsigned long)iSrc >= top) || (tmp1))
		#else
		if (((unsigned)iSrc >= top) || (tmp1))
		#endif
		{
			#ifdef MX_STRF_LONG
			tmp1 = (unsigned long)iSrc / top;	// Top digit
			#else
			tmp1 = (unsigned)iSrc / top;	// Top digit
			#endif
			sDst[idx] = '0' + tmp1;			// Add digit to buffer
			idx++;
			iSrc -= tmp1 * top;				// Remove digit
			tmp1 = 1;						// Add zeros now
		}
		top /= 10;							// Go to next digit
	}

	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
	return (sDst);
}



void FCI_TOLOWER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to lower case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'A') && (ch <= 'Z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

void FCI_TOUPPER(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
	if (iDst_len == 0) return;
	MX_UINT8 idx;
	MX_UINT8 ch;

	if (iSrc_len < iDst_len) iSrc_len = iDst_len; // Bound so cant overflow dest
	//copy source into destination and change to upper case
	for (idx=0; idx<iSrc_len; idx++)
	{
		ch = sSrc[idx];
		if ((ch >= 'a') && (ch <= 'z'))
		{
			ch ^= 0x20;
		}
		sDst[idx] = ch;
		if (ch == 0)
		{
			break;
		}
	}
	if (idx < iDst_len)						//add terminating null (if we can)
		sDst[idx] = '\0';
}

MX_UINT8 FCI_COMPARE(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_UINT8 iNoCase)
{
	MX_UINT8 idx = 0;
	MX_UINT8 ch1, ch2;

	while ((idx < iSrc1_len)&&(idx < iSrc2_len))
	{
		ch1 = sSrc1[idx];
		ch2 = sSrc2[idx];

		if (iNoCase)
		{
			if ((ch1 >= 'a') && (ch1 <= 'z'))
				ch1 = (ch1 & 0xDF);

			if ((ch2 >= 'a') && (ch2 <= 'z'))
				ch2 = (ch2 & 0xDF);
		}

		if (ch2 == 0)
		{
			if (ch1 == 0)
				return (0);				//end of iSrc1 as well, so we have a match
			else
				return (1);				//reached the end of iSrc2, but still more of iSrc1
		}
		else if (ch1 == 0)
			return (255);				//end of iSrc1 but not at end of iSrc2, so return -1
		else if (ch1 < ch2)
			return(255);
		else if (ch1 > ch2)
			return(1);
		// here if they are the same so far
		++idx;
	}

	// We've reached the end of one of the buffers without encountering a null terminator
	if (iSrc1_len > iSrc2_len)
	{
		if (sSrc1[idx] == 0)
			return (0);				// the next char in the longer buffer is a null so that's a match
		else
			return (1);
	}
	else if (iSrc1_len < iSrc2_len)
	{
		if (sSrc2[idx] == 0)
			return (0);
		else
			return (255);
	}
	return (0);						// the two buffers are the same size and contain the same data
}


MX_STRING FCI_FLOAT_TO_STRING(MX_FLOAT Number, MX_UINT8 Precision, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_SLONG whole;
	// MX_UINT8 str_length;
	MX_UINT8 idx;
	MX_UINT8 stringidx = 0;
	MX_FLOAT real, temp;
	MX_UINT8 old;
	MX_UINT8 temp_string[12];

	#ifdef _BOOSTC									//BoostC Floating Point

		float_rounding_mode = 3;					//Always round to zero
		whole = float32_to_int32(Number);			//Convert to whole integer
		temp = float32_from_int32(whole);			//Convert whole number back to floating point

		if (float32_ge(Number,0))
		{
			real = float32_sub(Number, temp);		//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = float32_sub(temp, Number);		//Subtract floating point number from whole number
		}
	#endif

	#ifdef HI_TECH_C								//HiTECH Floating Point

		whole = (int)Number;						//Convert to whole integer
		temp = whole;								//Convert whole number back to floating point

		if (Number >= 0)
		{
			real = Number - temp;					//Subtract whole number from floating point number
		}
		else
		{
			if (whole == 0)							//Fix -0 bug
			{
				String[stringidx] = '-';
				stringidx = stringidx + 1;
			}

			real = temp - Number;					//Subtract floating point number from whole number
		}
	#endif

	FCI_TOSTRING(whole, temp_string, sizeof(temp_string));		//Convert integer numbers to strings

	for (idx=0; temp_string[idx]; idx++)						//Copy whole part of number to string
	{
		if(stringidx < MSZ_String)
		{
			String[stringidx] = temp_string[idx];
			stringidx = stringidx + 1;
		}
	}

	if(stringidx < MSZ_String)						//Add decimal point to string
	{
		String[stringidx] = '.';
		stringidx = stringidx + 1;
	}

	for (idx = 0; idx < Precision; idx++)			//Output Real Part Of Number
	{
		if (stringidx >= MSZ_String)
			break;

		#ifdef _BOOSTC								//BoostC Floating Point
			real = float32_mul(real, 10);
			whole = float32_to_int32(real);			//Convert to whole integer
			temp = float32_from_int32(whole);		//Convert whole number back to floating point
			real = float32_sub(real, temp);			//Subtract whole number from floating point number
		#endif
		#ifdef HI_TECH_C							//HiTECH Floating Point
			real = real * 10;
			whole = (int)real;						//Convert to whole integer
			temp = whole;							//Convert whole number back to floating point
			real = real - temp;						//Subtract whole number from floating point number
		#endif

		String[stringidx] = '0' + whole;
		stringidx = stringidx + 1;
	}

	if(stringidx < MSZ_String)									//Add null termination to string
	{
		String[stringidx] = 0;
	}

	return String;
}











MX_STRING FCI_NUMBER_TO_HEX(MX_ULONG Number, MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 stringidx;
	MX_UINT8 idx = 0;
	MX_UINT8 temp;
	MX_UINT8 digit[8] = {0,0,0,0,0,0,0,0};

	#ifdef MX_STRF_LONG
		MX_UINT32 num = Number;
	#else
		MX_UINT16 num = Number;
	#endif

	String[0] = 0;

	//Check that output string is long enough to store result
	if((Number > 0xFFFF) && (MSZ_String < 10))
		return String;

	if((Number > 0xFF) && (MSZ_String < 6))
		return String;

	if((Number <= 0xFF) && (MSZ_String < 4))
		return String;

	//Initialise start of string with hexadecimal indicator
	String[0] = '0';
	String[1] = 'x';

	//Calculate hex values
	do
	{
		temp = num % 16;
		num = num >> 4;

		if(temp > 9)
		{
			temp = temp - 10;
			digit[idx] = temp + 'A';
		}
		else
			digit[idx] = temp + '0';

		idx = idx + 1;
	} while (num > 0);

	//Copy Hex values over to output string
	for (stringidx = 2; stringidx < (idx + 2); stringidx++)
		String[stringidx] = digit[idx - (stringidx - 1)];

	//Add null termination to string
	if(stringidx < MSZ_String)
	{
		String[stringidx] = 0;
	}

	return String;
}


MX_SINT32 FCI_STRING_TO_INT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_UINT8 bNegative = 0;
	MX_UINT8 idx = 0;
	MX_SINT32 RetVal = 0;

	//While string contains none numeric characters
	while (idx < MSZ_String && (String[idx] < '0' || String[idx] > '9'))
	{
		//Is number negative
		if(String[idx] == '-')
		{
			bNegative = 1;
			idx = idx + 1;
			break;
		}
		idx = idx + 1;
	}

	//While string contains a valid number
	while (idx < MSZ_String && String[idx] >= '0' && String[idx] <= '9')
	{
		//Pull MX_UINT8acter from string and add to running total
		RetVal = (long) RetVal * 10;
		RetVal = (long) RetVal + (String[idx] - '0');
		idx = idx + 1;
	}

	if (bNegative)
		RetVal = (long) 0 - RetVal;

	return RetVal;
}


MX_FLOAT FCI_STRING_TO_FLOAT(MX_STRING String, MX_UINT8 MSZ_String)
{
	MX_FLOAT RetVal = 0;
	MX_FLOAT real_divider = 1;
	MX_UINT32 whole, real;			//Changed from INT 23/07/10
	MX_UINT8 idx = 0;
	MX_UINT8 idx2 = 0;
	MX_UINT8 offset = 0;
	MX_UINT8 bNegative = 0;
	MX_UINT8 Comp_String[8];

	//Is number negative
	if(String[0] == '-')
	{
		bNegative = 1;
		offset = 1;
	}

	//Scan for decimal point
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] == '.')
			break;
	}

	//Convert whole portion of number from string
	whole = FCI_STRING_TO_INT (String, idx);

	//No decimal point found
	if(idx == MSZ_String)
	{
		#ifdef _BOOSTC
			RetVal = float32_from_int32(whole);
		#endif
		#ifdef HI_TECH_C
			RetVal = (int)whole;
		#endif
		return RetVal;
	}

	//Collect real portion of number into new string
	offset = idx + 1;
	for(idx=offset; idx<MSZ_String; idx++)
	{
		if(String[idx] >= '0' && String[idx] <= '9')
		{
			Comp_String[idx - offset] = String[idx];
			#ifdef _BOOSTC
				real_divider = float32_mul(real_divider, 0.1);
			#endif
			#ifdef HI_TECH_C
				real_divider = real_divider * 0.1;
			#endif
		}
		else
			break;
	}

	//Convert real portion of number from string
	real = FCI_STRING_TO_INT (Comp_String, (idx - offset));

	//Adjust weighting of values and combine into one float variable
	#ifdef _BOOSTC

		RetVal = float32_from_int32(real);
		RetVal = float32_mul(RetVal, real_divider);
		real_divider = float32_from_int32(whole);
		RetVal = float32_add(RetVal, real_divider);

		if (bNegative)
			RetVal = float32_sub(0, RetVal);

	#endif
	#ifdef HI_TECH_C

		RetVal = (MX_FLOAT)real;
		RetVal = RetVal * real_divider;
		real_divider = (MX_FLOAT)whole;
		RetVal = RetVal + real_divider;

		if (bNegative)
			RetVal = 0 - RetVal;
	#endif

	return RetVal;
}



/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :This differs from FCI_STRMOV() in that the bytes are copied from the
       :end of the string to the start
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRREV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix, len;
  FCI_GETLENGTH__x(sSrc, iSrc_len, len);
  if (len > iDst_len)
  {
    len = iDst_len;
  }
  ix = len;
  while (ix > 0)
  {
    ix--;
    sDst[ix] = sSrc[ix];
  }
  // No null terminate
  // Return length of string
  return len;
}


/*=----------------------------------------------------------------------=*\
   Use :Move but do not null-terminate sSrc to sDst, max len iSrc_len
       :Returns length of copy
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCI_STRMOV(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 ix;
  ix = 0;
  while (ix < iSrc_len && ix < iDst_len && sSrc[ix] != '\0')
  {
    sDst[ix] = sSrc[ix];
    ix++;
  }
  // No null terminate
  // Return length of string
  return ix;
}

/*=----------------------------------------------------------------------=*\
   Use :Concatenate sDst = (sSrc1 + sSrc2)
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SHEAD(MX_STRING sSrc1, MX_UINT8 iSrc1_len, MX_STRING sSrc2, MX_UINT8 iSrc2_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len, strt;

  len = 0;
  if (sSrc2 == sDst)
  {
    FCI_GETLENGTH__x(sSrc1, iSrc1_len, strt);
    if (strt < iDst_len)
    {
      // Copy second, in reverse
      // len = FCI_STRREV(sSrc2, iSrc2_len, sDst + strt, iDst_len - strt);
      FCI_GETLENGTH__x(sSrc2, iSrc2_len, len);
      if (len > (iDst_len - strt))
      {
        len = (iDst_len - strt); // Length of string to copy to
      }
      iSrc2_len = strt + len; // Use no longer needed var as an offset
      strt = len;
      while (strt > 0)
      {
        strt--;
        iSrc2_len--;
        sDst[iSrc2_len] = sSrc2[strt];
      }
      // Move first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, strt);
      len += strt;
    }
    else
    {
      // Copy first
      FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    }
  }
  else
  {
    // Copy first
    FCI_STRMOV__x(sSrc1, iSrc1_len, sDst, iDst_len, len);
    // Copy second
    if (len < iDst_len)
    {
      sSrc1 = sDst + len; // make temp copies in no longer used variables
      iSrc1_len = iDst_len - len;
      FCI_STRMOV__x(sSrc2, iSrc2_len, sSrc1, iSrc1_len, strt);
      len += strt;
    }
  }
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}


/*=----------------------------------------------------------------------=*\
   Use :Copy and null-terminate sSrc to sDst, max len iSrc_len
       :sDst is only null terminated if the concat doesnt overflow
       :
\*=----------------------------------------------------------------------=*/
void FCI_SCOPY(MX_STRING sSrc, MX_UINT8 iSrc_len, MX_STRING sDst, MX_UINT8 iDst_len)
{
  MX_UINT8 len;

  // Move first
  FCI_STRMOV__x(sSrc, iSrc_len, sDst, iDst_len, len);
  // Terminate (only if can)
  if (len < iDst_len)
  {
    sDst[len] = '\0';
  }
}




//************************************************************************************
//**  
//**  Source name:   D:\GitHub\Projects\MPPT\DAQ\firmware\AIVer000.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F14K50
//**  
//**  Generated by:  Flowcode v6.1.3.2
//**  Date:          Wednesday, February 22, 2017 12:40:38
//**  Users:         -1
//**  Registered to: 88263627
//**  Licence key:   K38DMR
//**  
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC
#define MX_CAL_PIC
#define MX_CLK_SPEED 12000000
#define FCP_NULL Unconnected_Port


#ifdef _BOOSTC
#pragma DATA 0x300000, 0x38
#endif
#ifdef HI_TECH_C
__CONFIG(0x38);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300001, 0x32
#endif
#ifdef HI_TECH_C
__CONFIG(0x32);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300002, 0x1F
#endif
#ifdef HI_TECH_C
__CONFIG(0x1F);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300003, 0x1E
#endif
#ifdef HI_TECH_C
__CONFIG(0x1E);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300004, 0x8
#endif
#ifdef HI_TECH_C
__CONFIG(0x8);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300005, 0x88
#endif
#ifdef HI_TECH_C
__CONFIG(0x88);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300006, 0x3
#endif
#ifdef HI_TECH_C
__CONFIG(0x3);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300007, 0xC0
#endif
#ifdef HI_TECH_C
__CONFIG(0xC0);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300008, 0x3
#endif
#ifdef HI_TECH_C
__CONFIG(0x3);
#endif
#ifdef _BOOSTC
#pragma DATA 0x300009, 0xE0
#endif
#ifdef HI_TECH_C
__CONFIG(0xE0);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000a, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000b, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000c, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif
#ifdef _BOOSTC
#pragma DATA 0x30000d, 0xFF
#endif
#ifdef HI_TECH_C
__CONFIG(0xFF);
#endif

/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_OUTSTRING 2
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_OUTSTR;
MX_GLOBAL MX_UINT8 FCV_OPERATION;
MX_GLOBAL MX_UINT16 FCV_READINPUT;
MX_GLOBAL MX_CHAR FCV_OUTSTRING[FCVsz_OUTSTRING];


/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define ADC_2_MX_ADC_ACTIME 40
#define MX_ADC_REF 
#define ADC_2_MX_ADC_VREFVOL 500
#define MX_ADC_CHANNEL_8 
#define MX_ADC_TYPE_19 
#define ADC_2_MX_ADC_VREFOP 0
#define ADC_2_MX_ADC_CONVSP 3
#define MX_ADC_BITS_10 
#define ADC_2_MX_ADC_CHANNEL 8

#define FCV_0aae2_cal_adc__FALSE (0)
#define FCV_0aae2_cal_adc__TRUE (1)

void FC_CAL_ADC_Disable();
void FC_CAL_ADC_Enable(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_CONV_SPEED, MX_UINT8 FCL_VREF, MX_UINT8 FCL_T_CHARGE);
MX_UINT16 FC_CAL_ADC_Sample(MX_UINT8 FCL_SAMPLE_MODE);

/*========================================================================*\
   Use :adc_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT16 FCD_08f42_adc_base__RawSampleInt();
MX_UINT8 FCD_08f42_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
void FCD_08f42_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08f42_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_SINT16 FCD_08f42_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_08f42_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_08f42_adc_base__GetVoltage();
void FCD_08f42_adc_base__RawEnable();
MX_UINT8 FCD_08f42_adc_base__RawSampleByte();
MX_UINT16 FCD_08f42_adc_base__GetInt();
void FCD_08f42_adc_base__RawDisable();
MX_UINT8 FCD_08f42_adc_base__GetByte();

/*========================================================================*\
   Use :v5__adc1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_03522_v5__adc1__RawSampleInt FCD_08f42_adc_base__RawSampleInt
#define FCD_03522_v5__adc1__RawAverageByte FCD_08f42_adc_base__RawAverageByte
#define FCD_03522_v5__adc1__GetString FCD_08f42_adc_base__GetString
#define FCD_03522_v5__adc1__GetAverageByte FCD_08f42_adc_base__GetAverageByte
#define FCD_03522_v5__adc1__RawAverageInt FCD_08f42_adc_base__RawAverageInt
#define FCD_03522_v5__adc1__GetAverageInt FCD_08f42_adc_base__GetAverageInt
#define FCD_03522_v5__adc1__GetVoltage FCD_08f42_adc_base__GetVoltage
#define FCD_03522_v5__adc1__RawEnable FCD_08f42_adc_base__RawEnable
#define FCD_03522_v5__adc1__RawSampleByte FCD_08f42_adc_base__RawSampleByte
#define FCD_03522_v5__adc1__GetInt FCD_08f42_adc_base__GetInt
#define FCD_03522_v5__adc1__RawDisable FCD_08f42_adc_base__RawDisable
#define FCD_03522_v5__adc1__GetByte FCD_08f42_adc_base__GetByte

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define ADC_1_MX_ADC_ACTIME 40
#define MX_ADC_REF 
#define ADC_1_MX_ADC_VREFVOL 500
#define MX_ADC_CHANNEL_7 
#define MX_ADC_TYPE_19 
#define ADC_1_MX_ADC_VREFOP 0
#define ADC_1_MX_ADC_CONVSP 3
#define MX_ADC_BITS_10 
#define ADC_1_MX_ADC_CHANNEL 7

#define FCV_0aae1_cal_adc__FALSE (0)
#define FCV_0aae1_cal_adc__TRUE (1)

void FC_CAL_ADC_Disable();
void FC_CAL_ADC_Enable(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_CONV_SPEED, MX_UINT8 FCL_VREF, MX_UINT8 FCL_T_CHARGE);
MX_UINT16 FC_CAL_ADC_Sample(MX_UINT8 FCL_SAMPLE_MODE);

/*========================================================================*\
   Use :adc_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT16 FCD_08f41_adc_base__RawSampleInt();
MX_UINT8 FCD_08f41_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
void FCD_08f41_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08f41_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_SINT16 FCD_08f41_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_08f41_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_08f41_adc_base__GetVoltage();
void FCD_08f41_adc_base__RawEnable();
MX_UINT8 FCD_08f41_adc_base__RawSampleByte();
MX_UINT16 FCD_08f41_adc_base__GetInt();
void FCD_08f41_adc_base__RawDisable();
MX_UINT8 FCD_08f41_adc_base__GetByte();

/*========================================================================*\
   Use :v5__adc0
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_03521_v5__adc0__RawSampleInt FCD_08f41_adc_base__RawSampleInt
#define FCD_03521_v5__adc0__RawAverageByte FCD_08f41_adc_base__RawAverageByte
#define FCD_03521_v5__adc0__GetString FCD_08f41_adc_base__GetString
#define FCD_03521_v5__adc0__GetAverageByte FCD_08f41_adc_base__GetAverageByte
#define FCD_03521_v5__adc0__RawAverageInt FCD_08f41_adc_base__RawAverageInt
#define FCD_03521_v5__adc0__GetAverageInt FCD_08f41_adc_base__GetAverageInt
#define FCD_03521_v5__adc0__GetVoltage FCD_08f41_adc_base__GetVoltage
#define FCD_03521_v5__adc0__RawEnable FCD_08f41_adc_base__RawEnable
#define FCD_03521_v5__adc0__RawSampleByte FCD_08f41_adc_base__RawSampleByte
#define FCD_03521_v5__adc0__GetInt FCD_08f41_adc_base__GetInt
#define FCD_03521_v5__adc0__RawDisable FCD_08f41_adc_base__RawDisable
#define FCD_03521_v5__adc0__GetByte FCD_08f41_adc_base__GetByte

/*========================================================================*\
   Use :dash_IO_flasher1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :COMPort
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :v5__usbserial0
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define dev_name 40,3,'F',0,'l',0,'o',0,'w',0,'c',0,'o',0,'d',0,'e',0,' ',0,'U',0,'S',0,'B',0,' ',0,'S',0,'e',0,'r',0,'i',0,'a',0,'l',0
#define dev_name_count 40
#define dev_name_DS 'F','l','o','w','c','o','d','e',' ','U','S','B',' ','S','e','r','i','a','l'
#define dev_name_count_DS 19
#define MX_USB_TYPE3
#define timeout 10
#define RX_BUF_SZ (64)
#define MX_VID 4799
#define enumeration_tout 0
#define TX_BUF_SZ (64)
#define major_version 1
#define MX_PID 61456
#define dev_manufacturer 46,3,'M',0,'a',0,'t',0,'r',0,'i',0,'x',0,' ',0,'M',0,'u',0,'l',0,'t',0,'i',0,'m',0,'e',0,'d',0,'i',0,'a',0,' ',0,'L',0,'t',0,'d',0,'.',0
#define dev_manufacturer_count 46
#define dev_manufacturer_DS 'M','a','t','r','i','x',' ','M','u','l','t','i','m','e','d','i','a',' ','L','t','d','.'
#define dev_manufacturer_count_DS 22
#define minor_version 0


/*=----------------------------------------------------------------------=*\
   Use :v5__usbserial0
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define MX_VERSION ((major_version << 8) | minor_version)

#ifdef MX_CAL_PIC							//8-bit PIC specific

	MX_UINT8 MX_USBNAME[dev_name_count] = {dev_name};		                    //Device name
10D8  0E28      	MOVLW 0x28
10DA  6F2E      	MOVWF gbl_MX_USBNAME, 1
10DC  0E03      	MOVLW 0x03
10DE  6F2F      	MOVWF gbl_MX_USBNAME+D'1', 1
10E0  0E46      	MOVLW 0x46
10E2  6F30      	MOVWF gbl_MX_USBNAME+D'2', 1
10E4  6B31      	CLRF gbl_MX_USBNAME+D'3', 1
10E6  0E6C      	MOVLW 0x6C
10E8  6F32      	MOVWF gbl_MX_USBNAME+D'4', 1
10EA  6B33      	CLRF gbl_MX_USBNAME+D'5', 1
10EC  0E6F      	MOVLW 0x6F
10EE  6F34      	MOVWF gbl_MX_USBNAME+D'6', 1
10F0  6B35      	CLRF gbl_MX_USBNAME+D'7', 1
10F2  0E77      	MOVLW 0x77
10F4  6F36      	MOVWF gbl_MX_USBNAME+D'8', 1
10F6  6B37      	CLRF gbl_MX_USBNAME+D'9', 1
10F8  0E63      	MOVLW 0x63
10FA  6F38      	MOVWF gbl_MX_USBNAME+D'10', 1
10FC  6B39      	CLRF gbl_MX_USBNAME+D'11', 1
10FE  0E6F      	MOVLW 0x6F
1100  6F3A      	MOVWF gbl_MX_USBNAME+D'12', 1
1102  6B3B      	CLRF gbl_MX_USBNAME+D'13', 1
1104  0E64      	MOVLW 0x64
1106  6F3C      	MOVWF gbl_MX_USBNAME+D'14', 1
1108  6B3D      	CLRF gbl_MX_USBNAME+D'15', 1
110A  0E65      	MOVLW 0x65
110C  6F3E      	MOVWF gbl_MX_USBNAME+D'16', 1
110E  6B3F      	CLRF gbl_MX_USBNAME+D'17', 1
1110  0E20      	MOVLW 0x20
1112  6F40      	MOVWF gbl_MX_USBNAME+D'18', 1
1114  6B41      	CLRF gbl_MX_USBNAME+D'19', 1
1116  0E55      	MOVLW 0x55
1118  6F42      	MOVWF gbl_MX_USBNAME+D'20', 1
111A  6B43      	CLRF gbl_MX_USBNAME+D'21', 1
111C  0E53      	MOVLW 0x53
111E  6F44      	MOVWF gbl_MX_USBNAME+D'22', 1
1120  6B45      	CLRF gbl_MX_USBNAME+D'23', 1
1122  0E42      	MOVLW 0x42
1124  6F46      	MOVWF gbl_MX_USBNAME+D'24', 1
1126  6B47      	CLRF gbl_MX_USBNAME+D'25', 1
1128  0E20      	MOVLW 0x20
112A  6F48      	MOVWF gbl_MX_USBNAME+D'26', 1
112C  6B49      	CLRF gbl_MX_USBNAME+D'27', 1
112E  0E53      	MOVLW 0x53
1130  6F4A      	MOVWF gbl_MX_USBNAME+D'28', 1
1132  6B4B      	CLRF gbl_MX_USBNAME+D'29', 1
1134  0E65      	MOVLW 0x65
1136  6F4C      	MOVWF gbl_MX_USBNAME+D'30', 1
1138  6B4D      	CLRF gbl_MX_USBNAME+D'31', 1
113A  0E72      	MOVLW 0x72
113C  6F4E      	MOVWF gbl_MX_USBNAME+D'32', 1
113E  6B4F      	CLRF gbl_MX_USBNAME+D'33', 1
1140  0E69      	MOVLW 0x69
1142  6F50      	MOVWF gbl_MX_USBNAME+D'34', 1
1144  6B51      	CLRF gbl_MX_USBNAME+D'35', 1
1146  0E61      	MOVLW 0x61
1148  6F52      	MOVWF gbl_MX_USBNAME+D'36', 1
114A  6B53      	CLRF gbl_MX_USBNAME+D'37', 1
114C  0E6C      	MOVLW 0x6C
114E  6F54      	MOVWF gbl_MX_USBNAME+D'38', 1
1150  6B55      	CLRF gbl_MX_USBNAME+D'39', 1

	MX_UINT8 MX_USBMFR[dev_manufacturer_count] = {dev_manufacturer};			//Manufacturer
1152  0E2E      	MOVLW 0x2E
1154  6F00      	MOVWF gbl_MX_USBMFR, 1
1156  0E03      	MOVLW 0x03
1158  6F01      	MOVWF gbl_MX_USBMFR+D'1', 1
115A  0E4D      	MOVLW 0x4D
115C  6F02      	MOVWF gbl_MX_USBMFR+D'2', 1
115E  6B03      	CLRF gbl_MX_USBMFR+D'3', 1
1160  0E61      	MOVLW 0x61
1162  6F04      	MOVWF gbl_MX_USBMFR+D'4', 1
1164  6B05      	CLRF gbl_MX_USBMFR+D'5', 1
1166  0E74      	MOVLW 0x74
1168  6F06      	MOVWF gbl_MX_USBMFR+D'6', 1
116A  6B07      	CLRF gbl_MX_USBMFR+D'7', 1
116C  0E72      	MOVLW 0x72
116E  6F08      	MOVWF gbl_MX_USBMFR+D'8', 1
1170  6B09      	CLRF gbl_MX_USBMFR+D'9', 1
1172  0E69      	MOVLW 0x69
1174  6F0A      	MOVWF gbl_MX_USBMFR+D'10', 1
1176  6B0B      	CLRF gbl_MX_USBMFR+D'11', 1
1178  0E78      	MOVLW 0x78
117A  6F0C      	MOVWF gbl_MX_USBMFR+D'12', 1
117C  6B0D      	CLRF gbl_MX_USBMFR+D'13', 1
117E  0E20      	MOVLW 0x20
1180  6F0E      	MOVWF gbl_MX_USBMFR+D'14', 1
1182  6B0F      	CLRF gbl_MX_USBMFR+D'15', 1
1184  0E4D      	MOVLW 0x4D
1186  6F10      	MOVWF gbl_MX_USBMFR+D'16', 1
1188  6B11      	CLRF gbl_MX_USBMFR+D'17', 1
118A  0E75      	MOVLW 0x75
118C  6F12      	MOVWF gbl_MX_USBMFR+D'18', 1
118E  6B13      	CLRF gbl_MX_USBMFR+D'19', 1
1190  0E6C      	MOVLW 0x6C
1192  6F14      	MOVWF gbl_MX_USBMFR+D'20', 1
1194  6B15      	CLRF gbl_MX_USBMFR+D'21', 1
1196  0E74      	MOVLW 0x74
1198  6F16      	MOVWF gbl_MX_USBMFR+D'22', 1
119A  6B17      	CLRF gbl_MX_USBMFR+D'23', 1
119C  0E69      	MOVLW 0x69
119E  6F18      	MOVWF gbl_MX_USBMFR+D'24', 1
11A0  6B19      	CLRF gbl_MX_USBMFR+D'25', 1
11A2  0E6D      	MOVLW 0x6D
11A4  6F1A      	MOVWF gbl_MX_USBMFR+D'26', 1
11A6  6B1B      	CLRF gbl_MX_USBMFR+D'27', 1
11A8  0E65      	MOVLW 0x65
11AA  6F1C      	MOVWF gbl_MX_USBMFR+D'28', 1
11AC  6B1D      	CLRF gbl_MX_USBMFR+D'29', 1
11AE  0E64      	MOVLW 0x64
11B0  6F1E      	MOVWF gbl_MX_USBMFR+D'30', 1
11B2  6B1F      	CLRF gbl_MX_USBMFR+D'31', 1
11B4  0E69      	MOVLW 0x69
11B6  6F20      	MOVWF gbl_MX_USBMFR+D'32', 1
11B8  6B21      	CLRF gbl_MX_USBMFR+D'33', 1
11BA  0E61      	MOVLW 0x61
11BC  6F22      	MOVWF gbl_MX_USBMFR+D'34', 1
11BE  6B23      	CLRF gbl_MX_USBMFR+D'35', 1
11C0  0E20      	MOVLW 0x20
11C2  6F24      	MOVWF gbl_MX_USBMFR+D'36', 1
11C4  6B25      	CLRF gbl_MX_USBMFR+D'37', 1
11C6  0E4C      	MOVLW 0x4C
11C8  6F26      	MOVWF gbl_MX_USBMFR+D'38', 1
11CA  6B27      	CLRF gbl_MX_USBMFR+D'39', 1
11CC  0E74      	MOVLW 0x74
11CE  6F28      	MOVWF gbl_MX_USBMFR+D'40', 1
11D0  6B29      	CLRF gbl_MX_USBMFR+D'41', 1
11D2  0E64      	MOVLW 0x64
11D4  6F2A      	MOVWF gbl_MX_USBMFR+D'42', 1
11D6  6B2B      	CLRF gbl_MX_USBMFR+D'43', 1
11D8  0E2E      	MOVLW 0x2E
11DA  6F2C      	MOVWF gbl_MX_USBMFR+D'44', 1
11DC  6B2D      	CLRF gbl_MX_USBMFR+D'45', 1


	// Global Defines
	#define CDC_TX_BUFFER_SIZE 	TX_BUF_SZ
	#define CDC_RX_BUFFER_SIZE 	RX_BUF_SZ
	#define CDC_DATA_ENDPOINT	3
	#define USB_HIGHEST_EP 		3
	#define USB_BUS_POWERED

	#ifdef MX_USB_TYPE1									//2455 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS	0x400
		#define USB_EP0_OUT_ADDR 	0x0500
		#define USB_EP0_IN_ADDR 	0x0508
		#define USB_EP2_IN_ADDR		0x0510
		#define USB_EP3_OUT_ADDR	0x0518
		#define USB_EP3_IN_ADDR		0x0520
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif

	#ifdef MX_USB_TYPE2									//2450 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS	0x400
		#define USB_EP0_OUT_ADDR 	0x0480
		#define USB_EP0_IN_ADDR 	0x0488
		#define USB_EP2_IN_ADDR		0x0490
		#define USB_EP3_OUT_ADDR	0x0498
		#define USB_EP3_IN_ADDR		0x04A0
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif

	#ifdef MX_USB_TYPE3									//14K50 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS	0x200
		#define USB_EP0_OUT_ADDR 	0x0280
		#define USB_EP0_IN_ADDR 	0x0288
		#define USB_EP2_IN_ADDR		0x0290
		#define USB_EP3_OUT_ADDR	0x0298
		#define USB_EP3_IN_ADDR		0x02A0
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif

	#ifdef MX_USB_TYPE4									//24J53 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS	0xD00
		#define USB_EP0_OUT_ADDR 	0x0E00
		#define USB_EP0_IN_ADDR 	0x0E08
		#define USB_EP2_IN_ADDR		0x0E10
		#define USB_EP3_OUT_ADDR	0x0E18
		#define USB_EP3_IN_ADDR		0x0E20
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif
	
	#ifdef MX_USB_TYPE5                                                             //16f1455 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS     0x2000
		#define USB_EP0_OUT_ADDR        0x2040
		#define USB_EP0_IN_ADDR         0x2048
		#define USB_EP2_IN_ADDR		    0x2050
		#define USB_EP3_OUT_ADDR	    0x2058
		#define USB_EP3_IN_ADDR		    0x2060
		#define PIRREG  		pir2
		#define PIEREG  		pie2
	#endif

	#ifdef MX_USB_TYPE6                                                             //18F45K50 Family
		#define USB_DESCRIPTOR_BASE_ADDRESS     0x400
		#define USB_EP0_OUT_ADDR        0x0500
		#define USB_EP0_IN_ADDR         0x0508
		#define USB_EP2_IN_ADDR		    0x0510
		#define USB_EP3_OUT_ADDR	    0x0518
		#define USB_EP3_IN_ADDR		    0x0520
		#define PIRREG  		pir3
		#define PIEREG  		pie3
	#endif

	#ifndef USB_DESCRIPTOR_BASE_ADDRESS
		#error "Target device does not have USB functionality"
	#endif

	#ifdef HI_TECH_C
		#error "USB library only supported by the BoostC compiler"
	#endif

	#define USB_EP0_OUT_SIZE 	8
	#define USB_EP0_IN_SIZE 	8
	#define USB_EP2_IN_SIZE		8
	#define USB_EP3_OUT_SIZE	8
	#define USB_EP3_IN_SIZE		8

	#define USB_CALLBACK_ON_SOF
	#define USB_CALLBACK_ON_DEVICE_CONFIGURED
	#define USB_CALLBACK_ON_CTRL_CLASS
	#define USB_EP_DATA_CALLBACK

	//Serial Number
	MX_UINT8 MX_SERIAL[10] = {10,3,'0',0,'0',0,'0',0,'1',0};
11DE  0E0A      	MOVLW 0x0A
11E0  0100      	MOVLB 0x00
11E2  6FE0      	MOVWF gbl_MX_SERIAL, 1
11E4  0E03      	MOVLW 0x03
11E6  6FE1      	MOVWF gbl_MX_SERIAL+D'1', 1
11E8  0E30      	MOVLW 0x30
11EA  6FE2      	MOVWF gbl_MX_SERIAL+D'2', 1
11EC  6BE3      	CLRF gbl_MX_SERIAL+D'3', 1
11EE  0E30      	MOVLW 0x30
11F0  6FE4      	MOVWF gbl_MX_SERIAL+D'4', 1
11F2  6BE5      	CLRF gbl_MX_SERIAL+D'5', 1
11F4  0E30      	MOVLW 0x30
11F6  6FE6      	MOVWF gbl_MX_SERIAL+D'6', 1
11F8  6BE7      	CLRF gbl_MX_SERIAL+D'7', 1
11FA  0E31      	MOVLW 0x31
11FC  6FE8      	MOVWF gbl_MX_SERIAL+D'8', 1
11FE  6BE9      	CLRF gbl_MX_SERIAL+D'9', 1


	// USB library includes
	#include "../../../../CAL/PIC/USB/pic_utils.h"
	#include "../../../../CAL/PIC/USB/pic_usb_buffer_mgt.c"
	#include "../../../../CAL/PIC/USB/pic_usb.c"
	#include "../../../../CAL/PIC/USB/usb_cdc_class.c"
	#include "../../../../CAL/PIC/USB/usb_config_serial.c"

	// Variable to hold status of the USB connection
	MX_UINT8 CDC_USB_status = 0;
128E  6BEF      	CLRF gbl_CDC_USB_status, 1


	// Variable to hold incoming data
	MX_UINT8 CDC_USB_Rx_String[CDC_RX_BUFFER_SIZE];

	void usb_device_configured_callback(void)

	{
		CDC_USB_status = 1;
037C  0E01      	MOVLW 0x01
037E  0101      	MOVLB 0x01
0380  6FEF      	MOVWF gbl_CDC_USB_status, 1

	}
0382  0012      	RETURN


#endif

#ifdef MX_CAL_PIC16					//16-bit PIC specific

	#ifndef MX_USB_TYPE1
		#error "Your target device does not support USB components"
	#endif

	// Global Defines
	#define USB_BUS_SENSE       1
	#define self_power          1
	#define tris_usb_bus_sense	1
	#define tris_self_power		1

	#define USB_CONFIG	"usb_serial_config.h"

	// USB library includes
	#include "../../../CAL/PIC16BIT/USB/usb_serial_config.h"
	#include "../../../CAL/PIC16BIT/USB/usb.h"
	#include "../../../CAL/PIC16BIT/USB/usb_function_cdc.h"
	#include "../../../CAL/PIC16BIT/USB/GenericTypeDefs.h"
	#include "../../../CAL/PIC16BIT/USB/Compiler.h"
	#include "../../../CAL/PIC16BIT/USB/usb_device.h"
	#include "../../../CAL/PIC16BIT/USB/usb_device.c"
	#include "../../../CAL/PIC16BIT/USB/usb_ch9.h"
    #if defined(__dsPIC33E__) 
      #include "../../../CAL/PIC16BIT/USB/usb_hal_dspic33e.c"
    #elif defined(__PIC24E__)
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24e.c"
    #else
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24.c"
    #endif
	#include "../../../CAL/PIC16BIT/USB/usb_function_cdc.c"
	#include "../../../CAL/PIC16BIT/USB/usb_common.h"
	#include "../../../CAL/PIC16BIT/USB/usb_hal.h"
    #if defined(__dsPIC33E__) 
      #include "../../../CAL/PIC16BIT/USB/usb_hal_dspic33e.h"
    #elif defined(__PIC24E__)
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24e.h"
    #else
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24.h"
    #endif
	
	// Device name and manufacturer
	ROM struct{BYTE bLength;BYTE bDscType;WORD string[dev_name_count_DS];}sd001={sizeof(sd001),USB_DESCRIPTOR_STRING,{dev_name_DS}};
	ROM struct{BYTE bLength;BYTE bDscType;WORD string[dev_manufacturer_count_DS];}sd002={sizeof(sd002),USB_DESCRIPTOR_STRING,{dev_manufacturer_DS}};

	#include "../../../CAL/PIC16BIT/USB/usb_serial_descriptors.c"
    #include "../../../CAL/PIC16BIT/USB/usb_cdc_handler.c"

#endif


#ifdef MX_CAL_AVR					//AVR specific

#include "config.h"
#include "lib_mcu/usb/usb_drv.h"
#include "modules\usb\device_chap9\usb_standard_request.h"
#include "usb_specific_request.h"
#include "uart_usb_lib.h"

extern U8    rx_counter;
extern U8    tx_counter;

S_line_coding line_coding;
S_line_status line_status;      // for detection of serial state input lines
S_serial_state serial_state;    // for serial state output lines

#endif

MX_UINT8 FCD_056e1_v5__usbserial0__SendString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA);
void FCD_056e1_v5__usbserial0__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_TIMEOUT_MS, MX_UINT8 FCL_LENGTH);
MX_UINT8 FCD_056e1_v5__usbserial0__SendByte(MX_UINT8 FCL_DATA);
MX_UINT16 FCD_056e1_v5__usbserial0__ReadByte(MX_UINT8 FCL_TIMEOUT_MS);
MX_UINT8 FCD_056e1_v5__usbserial0__Initialise();

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :adc_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f42_adc_base__RawSampleInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as as tring
       :
       :Returns : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_08f42_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_FLOAT FCL_SAMPLE;


	FCL_SAMPLE = FCD_08f42_adc_base__GetVoltage();

	FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL,20);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);

	FCR_RETVAL = FCD_08f42_adc_base__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_08f42_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT32 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f42_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);

	FCR_RETVAL = FCD_08f42_adc_base__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_08f42_adc_base__GetVoltage()
{
	//Local variable definitions
	MX_UINT16 FCL_SAMPLE;
	MX_FLOAT FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);

	FCL_SAMPLE = FC_CAL_ADC_Sample(1);

	FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.004883);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_08f42_adc_base__RawEnable()
{

	FC_CAL_ADC_Enable(8, 3, 0, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__RawSampleByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f42_adc_base__GetInt()

{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);
0EF6  0E08      	MOVLW 0x08
0EF8  0101      	MOVLB 0x01
0EFA  6FF4      	MOVWF FC_CAL_ADC_0004E_arg_Channel, 1
0EFC  0E03      	MOVLW 0x03
0EFE  6FF5      	MOVWF FC_CAL_ADC_0004E_arg_Conv_Speed, 1
0F00  6BF6      	CLRF FC_CAL_ADC_0004E_arg_Vref, 1
0F02  0E28      	MOVLW 0x28
0F04  6FF7      	MOVWF FC_CAL_ADC_0004E_arg_T_Charge, 1
0F06  EC18F007  	CALL FC_CAL_ADC_0004E


	FCR_RETVAL = FC_CAL_ADC_Sample(1);
0F0A  0E01      	MOVLW 0x01
0F0C  6FF4      	MOVWF FC_CAL_ADC_0004F_arg_Sample_Mode, 1
0F0E  ECF6F006  	CALL FC_CAL_ADC_0004F
0F12  51F7      	MOVF CompTempVarRet2646, W, 1
0F14  6FF2      	MOVWF FCD_08f42__0005E_1_FCR_RETVAL, 1
0F16  51F8      	MOVF CompTempVarRet2646+D'1', W, 1
0F18  6FF3      	MOVWF FCD_08f42__0005E_1_FCR_RETVAL+D'1', 1


	FC_CAL_ADC_Disable();
0F1A  EC60F007  	CALL FC_CAL_ADC_0004D


	return (FCR_RETVAL);
0F1E  51F2      	MOVF FCD_08f42__0005E_1_FCR_RETVAL, W, 1
0F20  6FF4      	MOVWF CompTempVarRet2674, 1
0F22  51F3      	MOVF FCD_08f42__0005E_1_FCR_RETVAL+D'1', W, 1
0F24  6FF5      	MOVWF CompTempVarRet2674+D'1', 1


}
0F26  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_08f42_adc_base__RawDisable()
{

	FC_CAL_ADC_Disable();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__GetByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(8, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :v5__adc1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :adc_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__RawSampleInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as as tring
       :
       :Returns : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_FLOAT FCL_SAMPLE;


	FCL_SAMPLE = FCD_08f41_adc_base__GetVoltage();

	FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL,20);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);

	FCR_RETVAL = FCD_08f41_adc_base__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_08f41_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT32 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);

	FCR_RETVAL = FCD_08f41_adc_base__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_08f41_adc_base__GetVoltage()
{
	//Local variable definitions
	MX_UINT16 FCL_SAMPLE;
	MX_FLOAT FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);

	FCL_SAMPLE = FC_CAL_ADC_Sample(1);

	FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.004883);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__RawEnable()
{

	FC_CAL_ADC_Enable(7, 3, 0, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__RawSampleByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__GetInt()

{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);
0F28  0E07      	MOVLW 0x07
0F2A  0101      	MOVLB 0x01
0F2C  6FF4      	MOVWF FC_CAL_ADC_0004E_arg_Channel, 1
0F2E  0E03      	MOVLW 0x03
0F30  6FF5      	MOVWF FC_CAL_ADC_0004E_arg_Conv_Speed, 1
0F32  6BF6      	CLRF FC_CAL_ADC_0004E_arg_Vref, 1
0F34  0E28      	MOVLW 0x28
0F36  6FF7      	MOVWF FC_CAL_ADC_0004E_arg_T_Charge, 1
0F38  EC18F007  	CALL FC_CAL_ADC_0004E


	FCR_RETVAL = FC_CAL_ADC_Sample(1);
0F3C  0E01      	MOVLW 0x01
0F3E  6FF4      	MOVWF FC_CAL_ADC_0004F_arg_Sample_Mode, 1
0F40  ECF6F006  	CALL FC_CAL_ADC_0004F
0F44  51F7      	MOVF CompTempVarRet2646, W, 1
0F46  6FF2      	MOVWF FCD_08f41__0006F_1_FCR_RETVAL, 1
0F48  51F8      	MOVF CompTempVarRet2646+D'1', W, 1
0F4A  6FF3      	MOVWF FCD_08f41__0006F_1_FCR_RETVAL+D'1', 1


	FC_CAL_ADC_Disable();
0F4C  EC60F007  	CALL FC_CAL_ADC_0004D


	return (FCR_RETVAL);
0F50  51F2      	MOVF FCD_08f41__0006F_1_FCR_RETVAL, W, 1
0F52  6FF4      	MOVWF CompTempVarRet2698, 1
0F54  51F3      	MOVF FCD_08f41__0006F_1_FCR_RETVAL+D'1', W, 1
0F56  6FF5      	MOVWF CompTempVarRet2698+D'1', 1


}
0F58  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__RawDisable()
{

	FC_CAL_ADC_Disable();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__GetByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(7, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :v5__adc0
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :dash_IO_flasher1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :COMPort
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :v5__usbserial0
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sends the specified data string to the host
       :
       :Parameters for macro SendString:
       :  Data[20] : Data string to send to the host
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_v5__usbserial0__SendString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA)

{
	//Local variable definitions
	MX_UINT16 FCL_TIMEOUT = (0x0);
0F86  6BF6      	CLRF FCD_056e1__00098_1_FCL_TIMEOUT, 1
0F88  6BF7      	CLRF FCD_056e1__00098_1_FCL_TIMEOUT+D'1', 1

	MX_UINT8 FCL_LENGTH;
	MX_UINT8 FCR_RETVAL;


	FCL_LENGTH = FCI_GETLENGTH(FCL_DATA, FCLsz_DATA);
0F8A  51F2      	MOVF FCD_056e1__00098_arg_FCL_DATA, W, 1
0F8C  6FFB      	MOVWF FCI_GETLEN_0003D_arg_sStr1, 1
0F8E  51F3      	MOVF FCD_056e1__00098_arg_FCL_DATA+D'1', W, 1
0F90  6FFC      	MOVWF FCI_GETLEN_0003D_arg_sStr1+D'1', 1
0F92  51F4      	MOVF FCD_056e1__00098_arg_FCLsz_DATA, W, 1
0F94  6FFD      	MOVWF FCI_GETLEN_0003D_arg_iStr1_len, 1
0F96  EC6BF007  	CALL FCI_GETLEN_0003D
0F9A  51FF      	MOVF CompTempVarRet1856, W, 1
0F9C  6FF8      	MOVWF FCD_056e1__00098_1_FCL_LENGTH, 1


	  #ifdef MX_CAL_PIC		//8-bit PIC specific

		MX_UINT8 n;

		while (usb_cdc_tx_empty() == 0 && FCL_TIMEOUT < 32000)	//Wait for outgoing buffer to empty
0F9E            label132
0F9E  EC9BF006  	CALL usb_cdc_tx_00093
0FA2  53FB      	MOVF CompTempVarRet2789, F, 1
0FA4  E10C      	BNZ	label134
0FA6  0E7D      	MOVLW 0x7D
0FA8  5DF7      	SUBWF FCD_056e1__00098_1_FCL_TIMEOUT+D'1', W, 1
0FAA  E102      	BNZ	label133
0FAC  0E00      	MOVLW 0x00
0FAE  5DF6      	SUBWF FCD_056e1__00098_1_FCL_TIMEOUT, W, 1
0FB0            label133
0FB0  E206      	BC	label134
0FBC  D7F0      	BRA	label132
0FBE            label134

			FCL_TIMEOUT = FCL_TIMEOUT + 1;
0FB2  53F6      	MOVF FCD_056e1__00098_1_FCL_TIMEOUT, F, 1
0FB4  53F7      	MOVF FCD_056e1__00098_1_FCL_TIMEOUT+D'1', F, 1
0FB6  2BF6      	INCF FCD_056e1__00098_1_FCL_TIMEOUT, F, 1
0FB8  B4D8      	BTFSC STATUS,Z
0FBA  2BF7      	INCF FCD_056e1__00098_1_FCL_TIMEOUT+D'1', F, 1


		if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
0FBE  0E00      	MOVLW 0x00
0FC0  63F6      	CPFSEQ FCD_056e1__00098_1_FCL_TIMEOUT, 1
0FC2  D006      	BRA	label135
0FC4  0E7D      	MOVLW 0x7D
0FC6  63F7      	CPFSEQ FCD_056e1__00098_1_FCL_TIMEOUT+D'1', 1
0FC8  D003      	BRA	label135
0FD0            label135

			return(1);
0FCA  0E01      	MOVLW 0x01
0FCC  6FFB      	MOVWF CompTempVarRet2802, 1


		// Flowcode strings are not necessarily null terminated
		// so we cannot use  usb_cdc_print_str(FCL_DATA);
		for(n = 0 ; (FCL_DATA[n] != 0)&&(n < FCL_LENGTH); n++)
0FD0  6BFA      	CLRF FCD_056e1__00098_1_n, 1
0FD2            label136
0FD2  51F3      	MOVF FCD_056e1__00098_arg_FCL_DATA+D'1', W, 1
0FD4  6EEA      	MOVWF FSR0H
0FD6  51F2      	MOVF FCD_056e1__00098_arg_FCL_DATA, W, 1
0FD8  25FA      	ADDWF FCD_056e1__00098_1_n, W, 1
0FDA  6EE9      	MOVWF FSR0L
0FDC  52EF      	MOVF INDF0, F
0FDE  E00E      	BZ	label137
0FE0  51F8      	MOVF FCD_056e1__00098_1_FCL_LENGTH, W, 1
0FE2  61FA      	CPFSLT FCD_056e1__00098_1_n, 1
0FE4  D00B      	BRA	label137
0FF8  2BFA      	INCF FCD_056e1__00098_1_n, F, 1
0FFA  D7EB      	BRA	label136
0FFC            label137

		{
			usb_cdc_putc(FCL_DATA[n]);
0FE6  51F3      	MOVF FCD_056e1__00098_arg_FCL_DATA+D'1', W, 1
0FE8  6EEA      	MOVWF FSR0H
0FEA  51F2      	MOVF FCD_056e1__00098_arg_FCL_DATA, W, 1
0FEC  25FA      	ADDWF FCD_056e1__00098_1_n, W, 1
0FEE  6EE9      	MOVWF FSR0L
0FF0  50EF      	MOVF INDF0, W
0FF2  6FFC      	MOVWF usb_cdc_pu_00091_arg_c, 1
0FF4  ECD0F006  	CALL usb_cdc_pu_00091

		}

	  #endif

	  #ifdef MX_CAL_PIC16	//16-bit PIC specific

		if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1))
		{
			return(2);	    //USB Not Configured
		}
		else
		{
			CDCTxService();		//Required or every other send fails

			while (mUSBUSARTIsTxTrfReady() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
				FCL_TIMEOUT = FCL_TIMEOUT + 1;

			if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
			{
				return(1);		//USB Not Ready
			}
			else
			{
				putUSBUSART(FCL_DATA, FCL_LENGTH);
			}
		}
		CDCTxService();

	  #endif

	#ifdef MX_CAL_AVR          //AVR specific

	        MX_UINT8 n;

	        if(!Is_device_enumerated()) {
	            return(2);
	        } else {
	            for(n = 0; (FCL_DATA[n] != 0) && (n < FCL_LENGTH); n++) {
	                FCL_TIMEOUT = 0;
	                while((!uart_usb_tx_ready()) && (FCL_TIMEOUT < 32000))
	                    FCL_TIMEOUT++;

	                if(FCL_TIMEOUT == 32000) {
	                    return(1);
	                } else {
	                    uart_usb_putchar(FCL_DATA[n]);
	                    Usb_ack_in_ready();
	                }
	            }
	        }

	#endif


	FCR_RETVAL = 0;
0FFC  6BF9      	CLRF FCD_056e1__00098_1_FCR_RETVAL, 1


	return (FCR_RETVAL);
0FFE  51F9      	MOVF FCD_056e1__00098_1_FCR_RETVAL, W, 1
1000  6FFB      	MOVWF CompTempVarRet2802, 1


}
0FCE  0012      	RETURN
1002  0012      	RETURN


/*=----------------------------------------------------------------------=*\
   Use :Retreives a string from the incoming data buffer. If data is available then the macro will return straight away. If there is no data available then the macro waits up the the period specified by the timeout before returning the value 255.
       :
       :Parameters for macro ReadString:
       :  Timeout_ms : Length of time to wait before timing out
       :  Length : Maximum number of bytes to try and read
       :
       :Returns : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_056e1_v5__usbserial0__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_TIMEOUT_MS, MX_UINT8 FCL_LENGTH)
{
	//Local variable definitions
	MX_UINT8 FCL_WAIT_FOREVER = (0x0);


	  #ifdef MX_CAL_PIC			//8-bit PIC specific

		MX_UINT8 Rx_Length;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while (FCL_TIMEOUT_MS || FCL_WAIT_FOREVER)
		{
			Rx_Length = usb_cdc_rx_avail();		// get length of incoming data string
			if (Rx_Length)
			{
				if (Rx_Length > FCL_LENGTH)
					Rx_Length = FCL_LENGTH;

				usb_ep_get_rx_buffer(Rx_Length, FCR_RETVAL);	// copy data string to local buffer

				if (Rx_Length < FCL_LENGTH)
					FCR_RETVAL[Rx_Length] = 0;		//Add null MX_UINT8acter to end of string
				return;
			}
			else
			{
				Wdt_Delay_Ms(1);
				FCL_TIMEOUT_MS = FCL_TIMEOUT_MS - 1;
			}
		}

	  #endif

	  #ifdef MX_CAL_PIC16									//16-bit PIC specific

		MX_UINT8 inner = 0;
		MX_UINT16 numBytesRead = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while(numBytesRead == 0 && FCL_TIMEOUT_MS > 0)
		{
			numBytesRead = getsUSBUSART(FCR_RETVAL, FCL_LENGTH);
			if ((FCL_WAIT_FOREVER == 0) && (numBytesRead == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
		}

	  #endif

	  #ifdef MX_CAL_AVR			//AVR specific

		MX_UINT8 Rx_Length = 0;
		MX_UINT8 inner = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while (FCL_TIMEOUT_MS || FCL_WAIT_FOREVER) {
	        if(uart_usb_test_hit()) {
	            FCL_WAIT_FOREVER = 0;
	            while(uart_usb_test_hit() && (Rx_Length <= FCL_LENGTH)) {
	                FCR_RETVAL[Rx_Length++] = uart_usb_getchar();
	            }
	        } else {
				inner++;
				delay_us(10);
				if (inner == 100) {
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
	        }
	    }
		if (Rx_Length < FCL_LENGTH)
		    FCR_RETVAL[Rx_Length] = 0;		//Add null MX_UINT8acter to end of string

	  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Sends the specified data byte to the host
       :
       :Parameters for macro SendByte:
       :  data : Data byte to send to the host
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_v5__usbserial0__SendByte(MX_UINT8 FCL_DATA)
{
	//Local variable definitions
	MX_UINT16 FCL_TIMEOUT = (0x0);
	MX_UINT8 FCR_RETVAL;


	  #ifdef MX_CAL_PIC		//8-bit PIC specific

		while (usb_cdc_tx_empty() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
			FCL_TIMEOUT = FCL_TIMEOUT + 1;

		if (FCL_TIMEOUT == 32000)			//Pipeline full or disconnected
			return(1);

		usb_cdc_putc(FCL_DATA);

	  #endif

	  #ifdef MX_CAL_PIC16		//16-bit PIC specific

	  	if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1))
	  	{
	  		return(2);		//USB Not Configured
	  	}
	  	else
	  	{
			CDCTxService();													//Required or every other send fails
			while (mUSBUSARTIsTxTrfReady() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
				FCL_TIMEOUT = FCL_TIMEOUT + 1;

			if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
			{
				return(1);		//USB Not Ready
			}
			else
			{
				putUSBUSART(&FCL_DATA,1);
			}
		}
		CDCTxService();

	  #endif

	#ifdef MX_CAL_AVR          //AVR specific
	        if(!Is_device_enumerated()) {
	            return(2);
	        } else {
	            Usb_select_endpoint(TX_EP);
	            while((uart_usb_tx_ready() == 0) && (FCL_TIMEOUT < 32000))
	                FCL_TIMEOUT++;

	            if(FCL_TIMEOUT == 32000) {
	                return(1);
	            } else {
	                uart_usb_putchar(FCL_DATA);
	                Usb_ack_in_ready();
	            }
	        }
	#endif


	FCR_RETVAL = 0;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Retreives the byte from the incoming data buffer. If data is available then the macro will return straight away. If there is no data available then the macro waits up the the period specified by the timeout before returning the value 255.
       :
       :Parameters for macro ReadByte:
       :  Timeout_ms : Number of milliseconds to wait before timing out
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_056e1_v5__usbserial0__ReadByte(MX_UINT8 FCL_TIMEOUT_MS)
{
	//Local variable definitions
	MX_UINT8 FCL_WAIT_FOREVER = (0x0);
	MX_UINT16 FCR_RETVAL;


	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	#else

		FCR_RETVAL = 255;

	#endif

	  #ifdef MX_CAL_PIC		//8-bit PIC specific

		static MX_UINT8 position = 0;
		static MX_UINT8 length = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		if (position == length)									// end of local string?
		{
			position = 0;

			length = usb_cdc_rx_avail();						// get length of incoming data string

			while (length == 0 && (FCL_TIMEOUT_MS || FCL_WAIT_FOREVER))	// wait for timeout_ms
			{
				Wdt_Delay_Ms(1);
				length = usb_cdc_rx_avail();					// get length of incoming data string
				FCL_TIMEOUT_MS = FCL_TIMEOUT_MS - 1;			// decrement timeout_ms
			}

			if(length == 0)
				return (FCR_RETVAL);							// return no data flag 255 / 0xFF

			usb_ep_get_rx_buffer(length, CDC_USB_Rx_String);	// copy data string to local buffer
		}

		FCR_RETVAL = CDC_USB_Rx_String[position];

		position = position + 1;

		return (FCR_RETVAL);

	  #endif

	  #ifdef MX_CAL_PIC16									//16-bit PIC specific

		MX_UINT8 retval[1];
		MX_UINT8 inner = 0;
		MX_UINT16 numBytesRead = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while(numBytesRead == 0 && FCL_TIMEOUT_MS > 0)
		{
			numBytesRead = getsUSBUSART(retval,1);
			if ((FCL_WAIT_FOREVER == 0) && (numBytesRead == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
	        else
	            FCR_RETVAL = retval[0];
		}
		return (FCR_RETVAL);

	  #endif

	  #ifdef MX_CAL_AVR		//AVRspecific

	    MX_UINT8 rx_rdy = 0;
	    MX_UINT8 inner = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while((rx_rdy == 0) && (FCL_TIMEOUT_MS > 0))
		{
			rx_rdy = uart_usb_test_hit();
	        if(rx_rdy)
	            FCR_RETVAL = uart_usb_getchar();

			if ((FCL_WAIT_FOREVER == 0) && (rx_rdy == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
		}
		return (FCR_RETVAL);
	  #endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Starts up the USB communications and attempts to enumerate.
       :Returns 0 for a successful startup or 255 for a enumeration timeout.
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_v5__usbserial0__Initialise()

{
	//Local variable definitions
	MX_UINT16 FCL_DELAY_COUNTER = (0x0);
0F5A  0101      	MOVLB 0x01
0F5C  6BF2      	CLRF FCD_056e1__000A1_1_FCL_DEL_000A2, 1
0F5E  6BF3      	CLRF FCD_056e1__000A1_1_FCL_DEL_000A2+D'1', 1

	MX_UINT8 FCR_RETVAL;


	#ifdef MX_CAL_PIC                                //8-bit PIC specific
	  #if defined(P18F24J50) || defined(P18F25J55) || defined(P18F26J50) || defined(P18F44J50) || defined(P18F45J50) || defined(P18F46J55) || defined(P18F87J50) ||  defined(P18F86J55) || defined(P18F86J50) || defined(P18F85J50) || defined(P18F67J50) || defined(P18F66J55) || defined(P18F66J50) || defined(P18F65J50)
	  //On the PIC18F87J50 Family of USB microcontrollers, the PLL will not power up and be enabled
	  //by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
	  //This allows the device to power up at a lower initial operating frequency, which can be
	  //advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
	  //operation.  On these devices, user firmware needs to manually set the OSCTUNE&lt;PLLEN&gt; bit to
	  //power up the PLL.
	  {
	      MX_UINT16 pll_startup_counter = 600;
	      OSCTUNEbits.PLLEN = 1;  //Enable the PLL and wait 2+ms until the PLL locks before enabling USB module
	      while(pll_startup_counter--);
	  }
	  //Device switches over automatically to PLL output after PLL is locked and ready.
	  #endif
	#endif

	#ifdef MX_CAL_PIC16                        //16-bit PIC specific
	  #if defined(P24FJ64GB004) || defined(P24FJ64GB002) || defined(P24FJ32GB004) || defined(P24FJ32GB002)
	  //On the PIC24FJ64GB004 Family of USB microcontrollers, the PLL will not power up and be enabled
	  //by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
	  //This allows the device to power up at a lower initial operating frequency, which can be
	  //advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
	  //operation.  On these devices, user firmware needs to manually set the CLKDIV&lt;PLLEN&gt; bit to
	  //power up the PLL.
	  {
	      MX_UINT16 pll_startup_counter = 600;
	      CLKDIVbits.PLLEN = 1;
	      while(pll_startup_counter--);
	  }
	  #endif
	#endif

	#ifdef MX_CAL_AVR                          //ATmega or AT90
	//  #if defined(AT90USB162)
	//  {
	      Usb_enable_regulator();
	//  }
	//  #endif
	#endif

	  #ifdef MX_CAL_PIC					//8-bit PIC specific
		usb_configure_structures();
0F60  EC7EF005  	CALL usb_config_00097

		kill_interrupts();						//turn off interrupts just in case
0F64            label130
0F64  9EF2      	BCF gbl_intcon,7
0F66  BEF2      	BTFSC gbl_intcon,7
0F68  D7FD      	BRA	label130

		usb_cdc_setup();
0F6A  ECA2F006  	CALL usb_cdc_se_00095

		usb_setup();
0F6E  EC66F005  	CALL usb_setup_00000

		turn_peripheral_ints_on();
0F72  8CF2      	BSF gbl_intcon,6

		turn_global_ints_on();
0F74  8EF2      	BSF gbl_intcon,7

		usb_enable_module();
0F76  EC78F005  	CALL usb_enable_00077

	  #elif defined MX_CAL_PIC16							//16-bit PIC specific
		USBDeviceInit();
		if(USB_BUS_SENSE && (USBGetDeviceState() == DETACHED_STATE))
			USBDeviceAttach();
	  #elif defined MX_CAL_AVR
	      usb_task_init();
	  #endif

	#if (0)

	//Code has been optimised out by the pre-processor
	#else

		#ifdef MX_CAL_PIC			//8-bit PIC specific
		  while(CDC_USB_status == 0);
0F7A            label131
0F7A  53EF      	MOVF gbl_CDC_USB_status, F, 1
0F7C  E0FE      	BZ	label131

		#elif defined MX_CAL_PIC16					//16-bit PIC specific
		  while(USBDeviceState != CONFIGURED_STATE);
		#elif defined MX_CAL_AVR
		  while(Is_device_enumerated() == 0) {
		    usb_task();
		  }
		  uart_usb_init();
		#endif

		FCR_RETVAL = 0;
0F7E  6BF4      	CLRF FCD_056e1__000A1_1_FCR_RETVAL, 1


	#endif

	return (FCR_RETVAL);
0F80  51F4      	MOVF FCD_056e1__000A1_1_FCR_RETVAL, W, 1
0F82  6FF5      	MOVWF CompTempVarRet2816, 1


}
0F84  0012      	RETURN



/*========================================================================*\
   Use :panel
       :Macro implementations
\*========================================================================*/


/*========================================================================*\
   Use :Main
\*========================================================================*/
void main()

{
ansel = 0x00;
1004  6A7E      	CLRF gbl_ansel

anselh = 0x00;
1006  6A7F      	CLRF gbl_anselh





	// Call Component Macro
	// Call Component Macro: v5__usbserial0::Initialise()
	FCD_056e1_v5__usbserial0__Initialise();
1008  ECADF007  	CALL FCD_056e1__000A1


	// Loop
	// Loop: While 1
	while (1)
100C            label138
108C  D7BF      	BRA	label138

	{

		// Call Component Macro
		// Call Component Macro: ReadInput=v5__adc0::GetInt()
		FCV_READINPUT = FCD_03521_v5__adc0__GetInt();
100C  EC94F007  	CALL FCD_08f41__0006F
1010  51F4      	MOVF CompTempVarRet2698, W, 1
1012  6FC8      	MOVWF gbl_FCV_READINPUT, 1
1014  51F5      	MOVF CompTempVarRet2698+D'1', W, 1
1016  6FC9      	MOVWF gbl_FCV_READINPUT+D'1', 1


		// Calculation
		// Calculation:
		//  //ReadInput = 1024
		//  ReadInput = ((ReadInput << 1) | 0x1001)
		//  OutString[0] = ReadInput
		//  OutString[1] = (ReadInput >> 8)
		FCV_READINPUT = ((FCV_READINPUT << 1) | 0x1001);
1018  53C8      	MOVF gbl_FCV_READINPUT, F, 1
101A  51C9      	MOVF gbl_FCV_READINPUT+D'1', W, 1
101C  6FF3      	MOVWF CompTempVar2820, 1
101E  90D8      	BCF STATUS,C
1020  37C8      	RLCF gbl_FCV_READINPUT, F, 1
1022  37F3      	RLCF CompTempVar2820, F, 1
1024  0E01      	MOVLW 0x01
1026  13C8      	IORWF gbl_FCV_READINPUT, F, 1
1028  51F3      	MOVF CompTempVar2820, W, 1
102A  0910      	IORLW 0x10
102C  6FF2      	MOVWF CompTempVar2818, 1
102E  51F2      	MOVF CompTempVar2818, W, 1
1030  6FC9      	MOVWF gbl_FCV_READINPUT+D'1', 1

		FCV_OUTSTRING[0] = FCV_READINPUT;
1032  51C8      	MOVF gbl_FCV_READINPUT, W, 1
1034  6FCA      	MOVWF gbl_FCV_OUTSTRING, 1

		FCV_OUTSTRING[1] = (FCV_READINPUT >> 8);
1036  51C9      	MOVF gbl_FCV_READINPUT+D'1', W, 1
1038  6FCB      	MOVWF gbl_FCV_OUTSTRING+D'1', 1


		// Call Component Macro
		// Call Component Macro: v5__usbserial0::SendString(OutString)
		FCD_056e1_v5__usbserial0__SendString(FCV_OUTSTRING, FCVsz_OUTSTRING);
103A  0E01      	MOVLW HIGH(gbl_FCV_OUTSTRING+D'0')
103C  6FF3      	MOVWF FCD_056e1__00098_arg_FCL_DATA+D'1', 1
103E  0ECA      	MOVLW LOW(gbl_FCV_OUTSTRING+D'0')
1040  6FF2      	MOVWF FCD_056e1__00098_arg_FCL_DATA, 1
1042  0E02      	MOVLW 0x02
1044  6FF4      	MOVWF FCD_056e1__00098_arg_FCLsz_DATA, 1
1046  6BF5      	CLRF FCD_056e1__00098_arg_FCLsz_DATA+D'1', 1
1048  ECC3F007  	CALL FCD_056e1__00098


		// Call Component Macro
		// Call Component Macro: ReadInput=v5__adc1::GetInt()
		FCV_READINPUT = FCD_03522_v5__adc1__GetInt();
104C  EC7BF007  	CALL FCD_08f42__0005E
1050  51F4      	MOVF CompTempVarRet2674, W, 1
1052  6FC8      	MOVWF gbl_FCV_READINPUT, 1
1054  51F5      	MOVF CompTempVarRet2674+D'1', W, 1
1056  6FC9      	MOVWF gbl_FCV_READINPUT+D'1', 1


		// Calculation
		// Calculation:
		//  //ReadInput = 1024
		//  ReadInput = ((ReadInput << 1) | 0x1001)
		//  OutString[0] = ReadInput
		//  OutString[1] = (ReadInput >> 8)
		FCV_READINPUT = ((FCV_READINPUT << 1) | 0x1001);
1058  53C8      	MOVF gbl_FCV_READINPUT, F, 1
105A  51C9      	MOVF gbl_FCV_READINPUT+D'1', W, 1
105C  6FF3      	MOVWF CompTempVar2828, 1
105E  90D8      	BCF STATUS,C
1060  37C8      	RLCF gbl_FCV_READINPUT, F, 1
1062  37F3      	RLCF CompTempVar2828, F, 1
1064  0E01      	MOVLW 0x01
1066  13C8      	IORWF gbl_FCV_READINPUT, F, 1
1068  51F3      	MOVF CompTempVar2828, W, 1
106A  0910      	IORLW 0x10
106C  6FF2      	MOVWF CompTempVar2826, 1
106E  51F2      	MOVF CompTempVar2826, W, 1
1070  6FC9      	MOVWF gbl_FCV_READINPUT+D'1', 1

		FCV_OUTSTRING[0] = FCV_READINPUT;
1072  51C8      	MOVF gbl_FCV_READINPUT, W, 1
1074  6FCA      	MOVWF gbl_FCV_OUTSTRING, 1

		FCV_OUTSTRING[1] = (FCV_READINPUT >> 8);
1076  51C9      	MOVF gbl_FCV_READINPUT+D'1', W, 1
1078  6FCB      	MOVWF gbl_FCV_OUTSTRING+D'1', 1


		// Call Component Macro
		// Call Component Macro: v5__usbserial0::SendString(OutString)
		FCD_056e1_v5__usbserial0__SendString(FCV_OUTSTRING, FCVsz_OUTSTRING);
107A  0E01      	MOVLW HIGH(gbl_FCV_OUTSTRING+D'0')
107C  6FF3      	MOVWF FCD_056e1__00098_arg_FCL_DATA+D'1', 1
107E  0ECA      	MOVLW LOW(gbl_FCV_OUTSTRING+D'0')
1080  6FF2      	MOVWF FCD_056e1__00098_arg_FCL_DATA, 1
1082  0E02      	MOVLW 0x02
1084  6FF4      	MOVWF FCD_056e1__00098_arg_FCLsz_DATA, 1
1086  6BF5      	CLRF FCD_056e1__00098_arg_FCLsz_DATA+D'1', 1
1088  ECC3F007  	CALL FCD_056e1__00098



	}

	mainendloop: goto mainendloop;
}




/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)

{

	

	#ifdef MX_CAL_PIC 
	  usb_handle_isr(); 
1294  CFEAF001  	MOVFF FSR0H,  Int1Context
1298  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
129C  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
12A0  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
12A4  0E99      	MOVLW 0x99
12A6  EF43F005  	GOTO	usb_handle_00072
12AA            label140

	#endif 
}
12AA  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
12AE  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
12B2  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
12B6  C001FFEA  	MOVFF Int1Context,  FSR0H
12BA  0011      	RETFIE 1






/*********************************************************************
 *                    Flowcode USB Component Code
 *
 * File: pic_usb_buffer_mgt.c
 *
 * (c) 2009 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 031008 | BR | Created
 * 190711 | BR | Confirmed current version
 * 250613 | JK | Added support for 16f1455
 * 230614 | LM | Support for 18F45K50
 ********************************************************************/

#include "pic_usb_buffer_mgt.h"

#if (USB_DESCRIPTOR_BASE_ADDRESS == 0x200)
	#define USBEP0O		0x200
	#define USBEP0I		0x204
	#define USBEP1O		0x208
	#define USBEP1I		0x20C
	#define USBEP2O		0x210
	#define USBEP2I		0x214
	#define USBEP3O		0x218
	#define USBEP3I		0x21C
#endif

#if (USB_DESCRIPTOR_BASE_ADDRESS == 0x400)
	#define USBEP0O		0x400
	#define USBEP0I		0x404
	#define USBEP1O		0x408
	#define USBEP1I		0x40C
	#define USBEP2O		0x410
	#define USBEP2I		0x414
	#define USBEP3O		0x418
	#define USBEP3I		0x41C
#endif

#if (USB_DESCRIPTOR_BASE_ADDRESS == 0xd00)
	#define USBEP0O		0xd00
	#define USBEP0I		0xd04
	#define USBEP1O		0xd08
	#define USBEP1I		0xd0C
	#define USBEP2O		0xd10
	#define USBEP2I		0xd14
	#define USBEP3O		0xd18
	#define USBEP3I		0xd1C
#endif

#if (USB_DESCRIPTOR_BASE_ADDRESS == 0x2000)
	#define USBEP0O		0x2000
	#define USBEP0I		0x2004
	#define USBEP1O		0x2008
	#define USBEP1I		0x200C
	#define USBEP2O		0x2010
	#define USBEP2I		0x2014
	#define USBEP3O		0x2018
	#define USBEP3I		0x201C
#endif

#if (USB_DESCRIPTOR_BASE_ADDRESS == 0x2000)
// JK: Work around BoostC issue with FSR access only for arrays
uns8	bd0aout_stat[1]@0x2000;
uns8	bd0aout_count[1]@0x2001;
uns16	bd0aout_addr[1]@0x2002;
uns8	bd0ain_stat[1]@0x2004;
uns8	bd0ain_count[1]@0x2005;
uns16	bd0ain_addr[1]@0x2006;

uns8	bd1aout_stat[1]@0x2008;
uns8	bd1aout_count[1]@0x2009;
uns16	bd1aout_addr[1]@0x200a;
uns8	bd1ain_stat[1]@0x200c;
uns8	bd1ain_count[1]@0x200d;
uns16	bd1ain_addr[1]@0x200e;

uns8	bd2aout_stat[1]@0x2010;
uns8	bd2aout_count[1]@0x2011;
uns16	bd2aout_addr[1]@0x2012;
uns8	bd2ain_stat[1]@0x2014;
uns8	bd2ain_count[1]@0x2015;
uns16	bd2ain_addr[1]@0x2016;

uns8	bd3aout_stat[1]@0x2018;
uns8	bd3aout_count[1]@0x2019;
uns16	bd3aout_addr[1]@0x201a;
uns8	bd3ain_stat[1]@0x201c;
uns8	bd3ain_count[1]@0x201d;
uns16	bd3ain_addr[1]@0x201e;

#else
buffer_descriptor bd0out@USBEP0O;
buffer_descriptor bd0in @USBEP0I;
buffer_descriptor bd1out@USBEP1O;
buffer_descriptor bd1in @USBEP1I;
buffer_descriptor bd2out@USBEP2O;
buffer_descriptor bd2in @USBEP2I;
buffer_descriptor bd3out@USBEP3O;
buffer_descriptor bd3in @USBEP3I;
#endif


uns8 buffer_0_out[USB_EP0_OUT_SIZE]@ USB_EP0_OUT_ADDR;
uns8 buffer_0_in [USB_EP0_IN_SIZE] @ USB_EP0_IN_ADDR;

#ifdef USB_EP1_IN_SIZE
	uns8 buffer_1_in [USB_EP1_IN_SIZE] @USB_EP1_IN_ADDR;
#endif
#ifdef USB_EP1_OUT_SIZE
	uns8 buffer_1_out [USB_EP1_OUT_SIZE] @ USB_EP1_OUT_ADDR;
#endif
#ifdef USB_EP2_IN_SIZE
	uns8 buffer_2_in [USB_EP2_IN_SIZE] @ USB_EP2_IN_ADDR;
#endif
#ifdef USB_EP2_OUT_SIZE
	uns8 buffer_2_out [USB_EP2_OUT_SIZE] @ USB_EP2_OUT_ADDR;
#endif
#ifdef USB_EP3_IN_SIZE
	uns8 buffer_3_in [USB_EP3_IN_SIZE] @ USB_EP3_IN_ADDR;
#endif
#ifdef USB_EP3_OUT_SIZE
	uns8 buffer_3_out [USB_EP3_OUT_SIZE] @ USB_EP3_OUT_ADDR;
#endif

#if 0 // !defined(MX_USB_TYPE5) && !defined (MX_USB_TYPE6)
buffer_descriptor * ep_in_bd_location[USB_HIGHEST_EP + 1];
buffer_descriptor * ep_out_bd_location[USB_HIGHEST_EP + 1];
#endif

uns8 * ep_in_buffer_location[USB_HIGHEST_EP + 1] = {
	// we always have EP0

	&buffer_0_in,	// ep 0 in buffer location
1200  0E02      	MOVLW HIGH(gbl_buffer_0_in+D'0')
1202  0101      	MOVLB 0x01
1204  6FE3      	MOVWF CompGblVar60, 1
1206  0E88      	MOVLW LOW(gbl_buffer_0_in+D'0')
1208  6F67      	MOVWF gbl_ep_in_buffer_location, 1
120A  51E3      	MOVF CompGblVar60, W, 1
120C  6F68      	MOVWF gbl_ep_in_buffer_location+D'1', 1


	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_IN_SIZE
			&buffer_1_in,	// ep 1 in buffer location
		#else
			0,
120E  6B69      	CLRF gbl_ep_in_buffer_location+D'2', 1
1210  6B6A      	CLRF gbl_ep_in_buffer_location+D'3', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_IN_SIZE
			&buffer_2_in,	// ep 2 in buffer location
1212  0E02      	MOVLW HIGH(gbl_buffer_2_in+D'0')
1214  6FE4      	MOVWF CompGblVar61, 1
1216  0E90      	MOVLW LOW(gbl_buffer_2_in+D'0')
1218  6F6B      	MOVWF gbl_ep_in_buffer_location+D'4', 1
121A  51E4      	MOVF CompGblVar61, W, 1
121C  6F6C      	MOVWF gbl_ep_in_buffer_location+D'5', 1

		#else
			0,
		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_IN_SIZE
			&buffer_3_in,	// ep 3 in buffer location
121E  0E02      	MOVLW HIGH(gbl_buffer_3_in+D'0')
1220  6FE5      	MOVWF CompGblVar62, 1
1222  0EA0      	MOVLW LOW(gbl_buffer_3_in+D'0')
1224  6F6D      	MOVWF gbl_ep_in_buffer_location+D'6', 1
1226  51E5      	MOVF CompGblVar62, W, 1
1228  6F6E      	MOVWF gbl_ep_in_buffer_location+D'7', 1

		#else
			0,
		#endif
	#endif
};

uns8 * ep_out_buffer_location[USB_HIGHEST_EP + 1] = {
	// we always have EP0

	&buffer_0_out,	// ep 0 in buffer location
122A  0E02      	MOVLW HIGH(gbl_buffer_0_out+D'0')
122C  6FE6      	MOVWF CompGblVar63, 1
122E  0E80      	MOVLW LOW(gbl_buffer_0_out+D'0')
1230  6F6F      	MOVWF gbl_ep_out_buffer_location, 1
1232  51E6      	MOVF CompGblVar63, W, 1
1234  6F70      	MOVWF gbl_ep_out_buffer_location+D'1', 1


	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_OUT_SIZE
			&buffer_1_out,	// ep 1 in buffer location
		#else
			0,
1236  6B71      	CLRF gbl_ep_out_buffer_location+D'2', 1
1238  6B72      	CLRF gbl_ep_out_buffer_location+D'3', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_OUT_SIZE
			&buffer_2_out,	// ep 2 in buffer location
		#else
			0,
123A  6B73      	CLRF gbl_ep_out_buffer_location+D'4', 1
123C  6B74      	CLRF gbl_ep_out_buffer_location+D'5', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_OUT_SIZE
			&buffer_3_out,	// ep 3 in buffer location
123E  0E02      	MOVLW HIGH(gbl_buffer_3_out+D'0')
1240  6FE7      	MOVWF CompGblVar64, 1
1242  0E98      	MOVLW LOW(gbl_buffer_3_out+D'0')
1244  6F75      	MOVWF gbl_ep_out_buffer_location+D'6', 1
1246  51E7      	MOVF CompGblVar64, W, 1
1248  6F76      	MOVWF gbl_ep_out_buffer_location+D'7', 1

		#else
			0,
		#endif
	#endif
};


uns16 ep_in_buffer_size[USB_HIGHEST_EP + 1] = {
	USB_EP0_IN_SIZE,
124A  0E08      	MOVLW 0x08
124C  6F77      	MOVWF gbl_ep_in_buffer_size, 1
124E  6B78      	CLRF gbl_ep_in_buffer_size+D'1', 1


	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_IN_SIZE
			USB_EP1_IN_SIZE,
		#else
			0,
1250  6B79      	CLRF gbl_ep_in_buffer_size+D'2', 1
1252  6B7A      	CLRF gbl_ep_in_buffer_size+D'3', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_IN_SIZE
			USB_EP2_IN_SIZE,
1254  0E08      	MOVLW 0x08
1256  6F7B      	MOVWF gbl_ep_in_buffer_size+D'4', 1
1258  6B7C      	CLRF gbl_ep_in_buffer_size+D'5', 1

		#else
			0,
		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_IN_SIZE
			USB_EP3_IN_SIZE,
125A  0E08      	MOVLW 0x08
125C  6F7D      	MOVWF gbl_ep_in_buffer_size+D'6', 1
125E  6B7E      	CLRF gbl_ep_in_buffer_size+D'7', 1

		#else
			0,
		#endif
	#endif
};



uns16 ep_out_buffer_size[USB_HIGHEST_EP + 1] = {
	USB_EP0_OUT_SIZE,
1260  0E08      	MOVLW 0x08
1262  6F7F      	MOVWF gbl_ep_out_buffer_size, 1
1264  6B80      	CLRF gbl_ep_out_buffer_size+D'1', 1


	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_OUT_SIZE
			USB_EP1_OUT_SIZE,
		#else
			0,
1266  6B81      	CLRF gbl_ep_out_buffer_size+D'2', 1
1268  6B82      	CLRF gbl_ep_out_buffer_size+D'3', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_OUT_SIZE
			USB_EP2_OUT_SIZE,
		#else
			0,
126A  6B83      	CLRF gbl_ep_out_buffer_size+D'4', 1
126C  6B84      	CLRF gbl_ep_out_buffer_size+D'5', 1

		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_OUT_SIZE
			USB_EP3_OUT_SIZE,
126E  0E08      	MOVLW 0x08
1270  6F85      	MOVWF gbl_ep_out_buffer_size+D'6', 1
1272  6B86      	CLRF gbl_ep_out_buffer_size+D'7', 1

		#else
			0,
		#endif
	#endif
};

/*********************************************************************
 *                    Flowcode USB Component Code
 *
 * File: pic_usb.c
 *
 * (c) 2009 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 031008 | BR | Created
 * 170409 | BR | Ammended Standard Request function to fix timeout bug in Linux systems
 * 010509 | BR | Slight change to allow 18FXXK50 devices to work correctly.
 * 190711 | BR | Confirmed current version
 * 230614 | LM | Support for 18F45K50
 ********************************************************************/

#include <memory.h>
#include "pic_usb.h"
#include "pic_usb_buffer_mgt.h"


// globally accessible variables

usb_state_type usb_state = st_POWERED;
1274  6BE0      	CLRF gbl_usb_state, 1


setup_data_packet usb_sdp;

uns8 usb_address;
control_mode_type control_mode;
uns16 delivery_bytes_to_send,
	  delivery_bytes_max_send,
		delivery_bytes_sent;
uns8 *delivery_ptr;
uns8 delivery_buffer_size;
uns8 *delivery_buffer;

usb_status_type usb_status;

void usb_configure_endpoints()

{

#ifdef USB_EP1
	set_bit  (uep1, EPHSHK);		// EP handshaking on
	#ifdef USB_EP1_OUT_SIZE
		set_bit(uep1, EPOUTEN);		// EP OUT enabled
	#else
		clear_bit(uep1, EPOUTEN);	// EP OUT disabled
	#endif
	#ifdef USB_EP1_IN_SIZE
		set_bit(uep1, EPINEN);		// EP IN enabled
	#else
		clear_bit(uep1, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep1, EPCONDIS);		// control transfers off

	// for IN
	#ifdef USB_EP1_IN_SIZE
		set_bit(bd1in_stat, DTS);		// turn on data togle sync TOGGLE
		clear_bit(bd1in_stat, KEN);		// clear the keep bit
		clear_bit(bd1in_stat, INCDIS);	// clear the increment disable
		clear_bit(bd1in_stat, DTSEN);
		clear_bit(bd1in_stat, BSTALL);	// clear stall bit
		clear_bit(bd1in_stat, BC9);
		clear_bit(bd1in_stat, BC8);

		clear_bit(bd1in_stat, UOWN);	// uC owns the buffer
	#endif
	// for OUT
	#ifdef USB_EP1_OUT_SIZE
		bd1out_count = USB_EP1_OUT_SIZE;
		bd1out_addr  = USB_EP1_OUT_ADDR;

		clear_bit(bd1out_stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd1out_stat, KEN);	// clear the keep bit
		clear_bit(bd1out_stat, INCDIS);	// clear the increment disable
		clear_bit(bd1out_stat, DTSEN);
		clear_bit(bd1out_stat, BSTALL);	// clear stall bit
		clear_bit(bd1out_stat, BC9);
		clear_bit(bd1out_stat, BC8);
		set_bit  (bd1out_stat, UOWN);	// SIE owns the buffer

	#endif
#endif

#ifdef USB_EP2
	set_bit  (uep2, EPHSHK);		// EP handshaking on
0384  010F      	MOVLB 0x0F
0386  8955      	BSF gbl_uep2,4, 1

	#ifdef USB_EP2_OUT_SIZE
		set_bit(uep2, EPOUTEN);		// EP OUT enabled
	#else
		clear_bit(uep2, EPOUTEN);	// EP OUT disabled
0388  9555      	BCF gbl_uep2,2, 1

	#endif
	#ifdef USB_EP2_IN_SIZE
		set_bit(uep2, EPINEN);		// EP IN enabled
038A  8355      	BSF gbl_uep2,1, 1

	#else
		clear_bit(uep2, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep2, EPCONDIS);		// control transfers off
038C  8755      	BSF gbl_uep2,3, 1


	// for IN
	#ifdef USB_EP2_IN_SIZE

		set_bit(bd2in_stat, DTS);		// turn on data togle sync TOGGLE
038E  0102      	MOVLB 0x02
0390  8D14      	BSF gbl_bd2in,6, 1

		clear_bit(bd2in_stat, KEN);		// clear the keep bit
0392  9B14      	BCF gbl_bd2in,5, 1

		clear_bit(bd2in_stat, INCDIS);	// clear the increment disable
0394  9914      	BCF gbl_bd2in,4, 1

		clear_bit(bd2in_stat, DTSEN);
0396  9714      	BCF gbl_bd2in,3, 1

		clear_bit(bd2in_stat, BSTALL);	// clear stall bit
0398  9514      	BCF gbl_bd2in,2, 1

		clear_bit(bd2in_stat, BC9);
039A  9314      	BCF gbl_bd2in,1, 1

		clear_bit(bd2in_stat, BC8);
039C  9114      	BCF gbl_bd2in,0, 1


		clear_bit(bd2in_stat, UOWN);	// uC owns the buffer
039E  9F14      	BCF gbl_bd2in,7, 1

	#endif
	// for OUT
	#ifdef USB_EP2_OUT_SIZE
		bd2out_count = USB_EP2_OUT_SIZE;
		bd2out_addr  = USB_EP2_OUT_ADDR;

		clear_bit(bd2out_stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd2out_stat, KEN);	// clear the keep bit
		clear_bit(bd2out_stat, INCDIS);	// clear the increment disable
		clear_bit(bd2out_stat, DTSEN);
		clear_bit(bd2out_stat, BSTALL);	// clear stall bit
		clear_bit(bd2out_stat, BC9);
		clear_bit(bd2out_stat, BC8);
		set_bit  (bd2out_stat, UOWN);	// SIE owns the buffer
	#endif
#endif

#ifdef USB_EP3
	set_bit  (uep3, EPHSHK);		// EP handshaking on
03A0  010F      	MOVLB 0x0F
03A2  8956      	BSF gbl_uep3,4, 1

	#ifdef USB_EP3_OUT_SIZE
		set_bit(uep3, EPOUTEN);		// EP OUT enabled
03A4  8556      	BSF gbl_uep3,2, 1

	#else
		clear_bit(uep3, EPOUTEN);	// EP OUT disabled
	#endif
	#ifdef USB_EP3_IN_SIZE
		set_bit(uep3, EPINEN);		// EP IN enabled
03A6  8356      	BSF gbl_uep3,1, 1

	#else
		clear_bit(uep3, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep3, EPCONDIS);		// control transfers off
03A8  8756      	BSF gbl_uep3,3, 1

	// for IN
	#ifdef USB_EP3_IN_SIZE
		set_bit(bd3in_stat, DTS);		// ready for toggle
03AA  0102      	MOVLB 0x02
03AC  8D1C      	BSF gbl_bd3in,6, 1

		clear_bit(bd3in_stat, KEN);		// clear the keep bit
03AE  9B1C      	BCF gbl_bd3in,5, 1

		clear_bit(bd3in_stat, INCDIS);	// clear the increment disable
03B0  991C      	BCF gbl_bd3in,4, 1

		clear_bit(bd3in_stat, DTSEN);
03B2  971C      	BCF gbl_bd3in,3, 1

		clear_bit(bd3in_stat, BSTALL);	// clear stall bit
03B4  951C      	BCF gbl_bd3in,2, 1

		clear_bit(bd3in_stat, BC9);
03B6  931C      	BCF gbl_bd3in,1, 1

		clear_bit(bd3in_stat, BC8);
03B8  911C      	BCF gbl_bd3in,0, 1


		clear_bit(bd3in_stat, UOWN);	// uC owns the buffer
03BA  9F1C      	BCF gbl_bd3in,7, 1

	#endif
	// for OUT
	#ifdef USB_EP3_OUT_SIZE
		bd3out_count = USB_EP3_OUT_SIZE;
03BC  0E08      	MOVLW 0x08
03BE  6F19      	MOVWF gbl_bd3out+D'1', 1

		bd3out_addr  = USB_EP3_OUT_ADDR;
03C0  0E98      	MOVLW 0x98
03C2  6F1A      	MOVWF gbl_bd3out+D'2', 1
03C4  0E02      	MOVLW 0x02
03C6  6F1B      	MOVWF gbl_bd3out+D'3', 1


		clear_bit(bd3out_stat, DTS);	// turn on data togle sync TOGGLE
03C8  9D18      	BCF gbl_bd3out,6, 1

		clear_bit(bd3out_stat, KEN);	// clear the keep bit
03CA  9B18      	BCF gbl_bd3out,5, 1

		clear_bit(bd3out_stat, INCDIS);	// clear the increment disable
03CC  9918      	BCF gbl_bd3out,4, 1

		clear_bit(bd3out_stat, DTSEN);
03CE  9718      	BCF gbl_bd3out,3, 1

		clear_bit(bd3out_stat, BSTALL);	// clear stall bit
03D0  9518      	BCF gbl_bd3out,2, 1

		clear_bit(bd3out_stat, BC9);
03D2  9318      	BCF gbl_bd3out,1, 1

		clear_bit(bd3out_stat, BC8);
03D4  9118      	BCF gbl_bd3out,0, 1

		set_bit  (bd3out_stat, UOWN);	// SIE owns the buffer
03D6  8F18      	BSF gbl_bd3out,7, 1

	#endif

#endif

}
03D8  0012      	RETURN


void usb_stall_ep0()

{
	set_bit(bd0in_stat, BSTALL);	// stall
00BC  0102      	MOVLB 0x02
00BE  8504      	BSF gbl_bd0in,2, 1

	set_bit(bd0in_stat, UOWN);		// SIE owns the buffer
00C0  8F04      	BSF gbl_bd0in,7, 1

	set_bit(bd0out_stat, BSTALL);	// stall
00C2  8500      	BSF gbl_bd0out,2, 1

	set_bit(bd0out_stat, UOWN);		// SIE owns the buffer
00C4  8F00      	BSF gbl_bd0out,7, 1

}
00C6  0012      	RETURN


void usb_send_data(uns8 ep, uns8 *data, uns8 send_count, bit first)

{
#if 1 // defined(MX_USB_TYPE5) || defined (MX_USB_TYPE6)
	uns8 count;
	uns8 *bdstat;
	uns8 *bdcount;
	uns16 *bdaddr;
	uns8 *buffer;

	// this is going to be an IN transaction

	// need to grab buffer descriptor
	buffer = ep_in_buffer_location[ep];
0154  0101      	MOVLB 0x01
0156  EE01F067  	LFSR 0x00, gbl_ep_in_buffer_location
015A  50E9      	MOVF FSR0L, W
015C  0102      	MOVLB 0x02
015E  512D      	MOVF usb_send_d_00078_arg_ep, W, 1
0160  6F3B      	MOVWF CompTempVar2734, 1
0162  90D8      	BCF STATUS,C
0164  353B      	RLCF CompTempVar2734, W, 1
0166  26E9      	ADDWF FSR0L, F
0168  50EE      	MOVF POSTINC0, W
016A  6F39      	MOVWF usb_send_d_00078_1_buffer, 1
016C  50EF      	MOVF INDF0, W
016E  6F3A      	MOVWF usb_send_d_00078_1_buffer+D'1', 1


	switch(ep) {
0212            label20

		case 0:
0170  532D      	MOVF usb_send_d_00078_arg_ep, F, 1
0172  E00A      	BZ	label16
0188            label16

			bdstat = &bd0in_stat;
0188  0E02      	MOVLW HIGH(gbl_bd0in+D'0')
018A  6F34      	MOVWF usb_send_d_00078_1_bdstat+D'1', 1
018C  0E04      	MOVLW LOW(gbl_bd0in+D'0')
018E  6F33      	MOVWF usb_send_d_00078_1_bdstat, 1

			bdcount = &bd0in_count;
0190  0E02      	MOVLW HIGH(gbl_bd0in+D'1')
0192  6F36      	MOVWF usb_send_d_00078_1_bdcount+D'1', 1
0194  0E05      	MOVLW LOW(gbl_bd0in+D'1')
0196  6F35      	MOVWF usb_send_d_00078_1_bdcount, 1

			bdaddr = &bd0in_addr;
0198  0E02      	MOVLW HIGH(gbl_bd0in+D'2')
019A  6F38      	MOVWF usb_send_d_00078_1_bdaddr+D'1', 1
019C  0E06      	MOVLW LOW(gbl_bd0in+D'2')
019E  6F37      	MOVWF usb_send_d_00078_1_bdaddr, 1

			break;
01A0  D038      	BRA	label20

		case 1:
0174  052D      	DECF usb_send_d_00078_arg_ep, W, 1
0176  E015      	BZ	label17
01A2            label17

			bdstat = &bd1in_stat;
01A2  0E02      	MOVLW HIGH(gbl_bd1in+D'0')
01A4  6F3B      	MOVWF CompTempVar2738, 1
01A6  0E0C      	MOVLW LOW(gbl_bd1in+D'0')
01A8  6F33      	MOVWF usb_send_d_00078_1_bdstat, 1
01AA  513B      	MOVF CompTempVar2738, W, 1
01AC  6F34      	MOVWF usb_send_d_00078_1_bdstat+D'1', 1

			bdcount = &bd1in_count;
01AE  0E02      	MOVLW HIGH(gbl_bd1in+D'1')
01B0  6F3B      	MOVWF CompTempVar2739, 1
01B2  0E0D      	MOVLW LOW(gbl_bd1in+D'1')
01B4  6F35      	MOVWF usb_send_d_00078_1_bdcount, 1
01B6  513B      	MOVF CompTempVar2739, W, 1
01B8  6F36      	MOVWF usb_send_d_00078_1_bdcount+D'1', 1

			bdaddr = &bd1in_addr;
01BA  0E02      	MOVLW HIGH(gbl_bd1in+D'2')
01BC  6F3B      	MOVWF CompTempVar2740, 1
01BE  0E0E      	MOVLW LOW(gbl_bd1in+D'2')
01C0  6F37      	MOVWF usb_send_d_00078_1_bdaddr, 1
01C2  513B      	MOVF CompTempVar2740, W, 1
01C4  6F38      	MOVWF usb_send_d_00078_1_bdaddr+D'1', 1

			break;
01C6  D025      	BRA	label20

		case 2:
0178  0E02      	MOVLW 0x02
017A  632D      	CPFSEQ usb_send_d_00078_arg_ep, 1
017C  D001      	BRA	label15
017E  D024      	BRA	label18
0180            label15
0186  D033      	BRA	label19
01C8            label18

			bdstat = &bd2in_stat;
01C8  0E02      	MOVLW HIGH(gbl_bd2in+D'0')
01CA  6F3B      	MOVWF CompTempVar2741, 1
01CC  0E14      	MOVLW LOW(gbl_bd2in+D'0')
01CE  6F33      	MOVWF usb_send_d_00078_1_bdstat, 1
01D0  513B      	MOVF CompTempVar2741, W, 1
01D2  6F34      	MOVWF usb_send_d_00078_1_bdstat+D'1', 1

			bdcount = &bd2in_count;
01D4  0E02      	MOVLW HIGH(gbl_bd2in+D'1')
01D6  6F3B      	MOVWF CompTempVar2742, 1
01D8  0E15      	MOVLW LOW(gbl_bd2in+D'1')
01DA  6F35      	MOVWF usb_send_d_00078_1_bdcount, 1
01DC  513B      	MOVF CompTempVar2742, W, 1
01DE  6F36      	MOVWF usb_send_d_00078_1_bdcount+D'1', 1

			bdaddr = &bd2in_addr;
01E0  0E02      	MOVLW HIGH(gbl_bd2in+D'2')
01E2  6F3B      	MOVWF CompTempVar2743, 1
01E4  0E16      	MOVLW LOW(gbl_bd2in+D'2')
01E6  6F37      	MOVWF usb_send_d_00078_1_bdaddr, 1
01E8  513B      	MOVF CompTempVar2743, W, 1
01EA  6F38      	MOVWF usb_send_d_00078_1_bdaddr+D'1', 1

			break;
01EC  D012      	BRA	label20

		case 3:
0180  0E03      	MOVLW 0x03
0182  632D      	CPFSEQ usb_send_d_00078_arg_ep, 1
0184  D046      	BRA	label20
01EE            label19

			bdstat = &bd3in_stat;
01EE  0E02      	MOVLW HIGH(gbl_bd3in+D'0')
01F0  6F3B      	MOVWF CompTempVar2744, 1
01F2  0E1C      	MOVLW LOW(gbl_bd3in+D'0')
01F4  6F33      	MOVWF usb_send_d_00078_1_bdstat, 1
01F6  513B      	MOVF CompTempVar2744, W, 1
01F8  6F34      	MOVWF usb_send_d_00078_1_bdstat+D'1', 1

			bdcount = &bd3in_count;
01FA  0E02      	MOVLW HIGH(gbl_bd3in+D'1')
01FC  6F3B      	MOVWF CompTempVar2745, 1
01FE  0E1D      	MOVLW LOW(gbl_bd3in+D'1')
0200  6F35      	MOVWF usb_send_d_00078_1_bdcount, 1
0202  513B      	MOVF CompTempVar2745, W, 1
0204  6F36      	MOVWF usb_send_d_00078_1_bdcount+D'1', 1

			bdaddr = &bd3in_addr;
0206  0E02      	MOVLW HIGH(gbl_bd3in+D'2')
0208  6F3B      	MOVWF CompTempVar2746, 1
020A  0E1E      	MOVLW LOW(gbl_bd3in+D'2')
020C  6F37      	MOVWF usb_send_d_00078_1_bdaddr, 1
020E  513B      	MOVF CompTempVar2746, W, 1
0210  6F38      	MOVWF usb_send_d_00078_1_bdaddr+D'1', 1

	}

	if (test_bit(*bdstat, UOWN))
0212  5134      	MOVF usb_send_d_00078_1_bdstat+D'1', W, 1
0214  6EEA      	MOVWF FSR0H
0216  5133      	MOVF usb_send_d_00078_1_bdstat, W, 1
0218  6EE9      	MOVWF FSR0L
021A  BEEF      	BTFSC INDF0,7

	{
		return;
	}

	count = 0;
021E  6B32      	CLRF usb_send_d_00078_1_count, 1

	while ((count < send_count))
0220            label21
0220  5130      	MOVF usb_send_d_00078_arg_send_count, W, 1
0222  6132      	CPFSLT usb_send_d_00078_1_count, 1
0224  D013      	BRA	label22
024A  D7EA      	BRA	label21
024C            label22

	{
	    buffer[count] = data[count];
0226  512F      	MOVF usb_send_d_00078_arg_data+D'1', W, 1
0228  6EEA      	MOVWF FSR0H
022A  512E      	MOVF usb_send_d_00078_arg_data, W, 1
022C  6EE9      	MOVWF FSR0L
022E  5132      	MOVF usb_send_d_00078_1_count, W, 1
0230  6F3B      	MOVWF CompTempVar2749, 1
0232  513B      	MOVF CompTempVar2749, W, 1
0234  26E9      	ADDWF FSR0L, F
0236  50EF      	MOVF INDF0, W
0238  6F3C      	MOVWF CompTempVar2750, 1
023A  513A      	MOVF usb_send_d_00078_1_buffer+D'1', W, 1
023C  6EEA      	MOVWF FSR0H
023E  5139      	MOVF usb_send_d_00078_1_buffer, W, 1
0240  2532      	ADDWF usb_send_d_00078_1_count, W, 1
0242  6EE9      	MOVWF FSR0L
0244  513C      	MOVF CompTempVar2750, W, 1
0246  6EEF      	MOVWF INDF0

	    count++;
0248  2B32      	INCF usb_send_d_00078_1_count, F, 1

	}

	*bdcount = count;
024C  5136      	MOVF usb_send_d_00078_1_bdcount+D'1', W, 1
024E  6EEA      	MOVWF FSR0H
0250  5135      	MOVF usb_send_d_00078_1_bdcount, W, 1
0252  6EE9      	MOVWF FSR0L
0254  5132      	MOVF usb_send_d_00078_1_count, W, 1
0256  6EEF      	MOVWF INDF0

	*bdaddr = (uns16)buffer;
0258  5138      	MOVF usb_send_d_00078_1_bdaddr+D'1', W, 1
025A  6EEA      	MOVWF FSR0H
025C  5137      	MOVF usb_send_d_00078_1_bdaddr, W, 1
025E  6EE9      	MOVWF FSR0L
0260  2AE9      	INCF FSR0L, F
0262  5139      	MOVF usb_send_d_00078_1_buffer, W, 1
0264  6F3B      	MOVWF CompTempVar2751, 1
0266  513A      	MOVF usb_send_d_00078_1_buffer+D'1', W, 1
0268  6EEF      	MOVWF INDF0
026A  06E9      	DECF FSR0L, F
026C  513B      	MOVF CompTempVar2751, W, 1
026E  6EEF      	MOVWF INDF0

	if (first)
0270  A131      	BTFSS usb_send_d_00078_arg_first,0, 1
0272  D005      	BRA	label23
027E            label23

	{
		clear_bit(*bdstat, DTS);
0274  5134      	MOVF usb_send_d_00078_1_bdstat+D'1', W, 1
0276  6EEA      	MOVWF FSR0H
0278  5133      	MOVF usb_send_d_00078_1_bdstat, W, 1
027A  6EE9      	MOVWF FSR0L
027C  9CEF      	BCF INDF0,6

	}
	if (test_bit(*bdstat, DTS))
027E  5134      	MOVF usb_send_d_00078_1_bdstat+D'1', W, 1
0280  6EEA      	MOVWF FSR0H
0282  5133      	MOVF usb_send_d_00078_1_bdstat, W, 1
0284  6EE9      	MOVWF FSR0L
0286  ACEF      	BTFSS INDF0,6
0288  D006      	BRA	label24
0296            label24

		clear_bit(*bdstat, DTS);
028A  5134      	MOVF usb_send_d_00078_1_bdstat+D'1', W, 1
028C  6EEA      	MOVWF FSR0H
028E  5133      	MOVF usb_send_d_00078_1_bdstat, W, 1
0290  6EE9      	MOVWF FSR0L
0292  9CEF      	BCF INDF0,6

	else set_bit(*bdstat, DTS);
0294  D005      	BRA	label25
0296  5134      	MOVF usb_send_d_00078_1_bdstat+D'1', W, 1
0298  6EEA      	MOVWF FSR0H
029A  5133      	MOVF usb_send_d_00078_1_bdstat, W, 1
029C  6EE9      	MOVWF FSR0L
029E  8CEF      	BSF INDF0,6
02A0            label25

	clear_bit(*bdstat, KEN);		// clear the keep bit
02A0  5134      	MOVF usb_send_d_00078_1_bdstat+D'1', W, 1
02A2  6EEA      	MOVWF FSR0H
02A4  5133      	MOVF usb_send_d_00078_1_bdstat, W, 1
02A6  6EE9      	MOVWF FSR0L
02A8  9AEF      	BCF INDF0,5

	clear_bit(*bdstat, INCDIS);	// clear the increment disable
02AA  98EF      	BCF INDF0,4

	set_bit  (*bdstat, DTSEN);
02AC  86EF      	BSF INDF0,3

	clear_bit(*bdstat, BSTALL);	// clear stall bit
02AE  94EF      	BCF INDF0,2

	clear_bit(*bdstat, BC9);
02B0  92EF      	BCF INDF0,1

	clear_bit(*bdstat, BC8);
02B2  90EF      	BCF INDF0,0


	set_bit  (*bdstat, UOWN);		// SIE owns the buffer
02B4  8EEF      	BSF INDF0,7

#else
	uns8 count;
	buffer_descriptor *bd;
	uns8 *buffer;

	// this is going to be an IN transaction

	// need to grab buffer descriptor
	buffer = ep_in_buffer_location[ep];

	bd = ep_in_bd_location[ep];

	if (test_bit(bd->stat, UOWN))
	{
		return;
	}

	count = 0;
	while ((count < send_count))
	{
	    buffer[count] = data[count];
	    count++;
	}

	bd->count = count;
	bd->addr = (uns16)buffer;
	if (first)
	{
		clear_bit(bd->stat, DTS);
	}
	if (test_bit(bd->stat, DTS))
		clear_bit(bd->stat, DTS);
	else set_bit(bd->stat, DTS);
	clear_bit(bd->stat, KEN);		// clear the keep bit
	clear_bit(bd->stat, INCDIS);	// clear the increment disable
	set_bit  (bd->stat, DTSEN);
	clear_bit(bd->stat, BSTALL);	// clear stall bit
	clear_bit(bd->stat, BC9);
	clear_bit(bd->stat, BC8);

	set_bit  (bd->stat, UOWN);		// SIE owns the buffer
#endif
}
021C  0012      	RETURN
02B6  0012      	RETURN



void usb_send_data_chunk()

{

uns8 count;

	count = 0;
0012  0102      	MOVLB 0x02
0014  6B31      	CLRF usb_send_d_0007A_1_count, 1

	while ((count < delivery_buffer_size) &&
0016            label2
0016  0101      	MOVLB 0x01
0018  51E8      	MOVF gbl_delivery_buffer_size, W, 1
001A  0102      	MOVLB 0x02
001C  6131      	CPFSLT usb_send_d_0007A_1_count, 1
001E  D025      	BRA	label5
0068  D7D6      	BRA	label2
006A            label5

			(delivery_bytes_sent < delivery_bytes_to_send) &&
0020  0101      	MOVLB 0x01
0022  51CD      	MOVF gbl_delivery_bytes_to_send+D'1', W, 1
0024  5DD1      	SUBWF gbl_delivery_bytes_sent+D'1', W, 1
0026  E102      	BNZ	label3
0028  51CC      	MOVF gbl_delivery_bytes_to_send, W, 1
002A  5DD0      	SUBWF gbl_delivery_bytes_sent, W, 1
002C            label3
002C  E21E      	BC	label5

			(delivery_bytes_sent < delivery_bytes_max_send)) {
002E  51CF      	MOVF gbl_delivery_bytes_max_send+D'1', W, 1
0030  5DD1      	SUBWF gbl_delivery_bytes_sent+D'1', W, 1
0032  E102      	BNZ	label4
0034  51CE      	MOVF gbl_delivery_bytes_max_send, W, 1
0036  5DD0      	SUBWF gbl_delivery_bytes_sent, W, 1
0038            label4
0038  E218      	BC	label5

	    delivery_buffer[count] = *delivery_ptr;
003A  51D3      	MOVF gbl_delivery_ptr+D'1', W, 1
003C  6EEA      	MOVWF FSR0H
003E  51D2      	MOVF gbl_delivery_ptr, W, 1
0040  6EE9      	MOVWF FSR0L
0042  50EF      	MOVF INDF0, W
0044  0102      	MOVLB 0x02
0046  6F32      	MOVWF CompTempVar2756, 1
0048  0101      	MOVLB 0x01
004A  51D5      	MOVF gbl_delivery_buffer+D'1', W, 1
004C  6EEA      	MOVWF FSR0H
004E  51D4      	MOVF gbl_delivery_buffer, W, 1
0050  0102      	MOVLB 0x02
0052  2531      	ADDWF usb_send_d_0007A_1_count, W, 1
0054  6EE9      	MOVWF FSR0L
0056  5132      	MOVF CompTempVar2756, W, 1
0058  6EEF      	MOVWF INDF0

	    delivery_ptr++;
005A  0101      	MOVLB 0x01
005C  4BD2      	INFSNZ gbl_delivery_ptr, F, 1
005E  2BD3      	INCF gbl_delivery_ptr+D'1', F, 1

	    delivery_bytes_sent++;
0060  4BD0      	INFSNZ gbl_delivery_bytes_sent, F, 1
0062  2BD1      	INCF gbl_delivery_bytes_sent+D'1', F, 1

	    count++;
0064  0102      	MOVLB 0x02
0066  2B31      	INCF usb_send_d_0007A_1_count, F, 1

	}

	if ((count < delivery_buffer_size) &&
006A  0101      	MOVLB 0x01
006C  51E8      	MOVF gbl_delivery_buffer_size, W, 1
006E  0102      	MOVLB 0x02
0070  6131      	CPFSLT usb_send_d_0007A_1_count, 1
0072  D010      	BRA	label8
0094            label8

			((delivery_bytes_sent == delivery_bytes_max_send) ||
0074  0101      	MOVLB 0x01
0076  51CE      	MOVF gbl_delivery_bytes_max_send, W, 1
0078  63D0      	CPFSEQ gbl_delivery_bytes_sent, 1
007A  D004      	BRA	label6
007C  51CF      	MOVF gbl_delivery_bytes_max_send+D'1', W, 1
007E  63D1      	CPFSEQ gbl_delivery_bytes_sent+D'1', 1
0080  D001      	BRA	label6
0082  D006      	BRA	label7
0084            label6

			(delivery_bytes_sent == delivery_bytes_to_send))) {
0084  51CC      	MOVF gbl_delivery_bytes_to_send, W, 1
0086  63D0      	CPFSEQ gbl_delivery_bytes_sent, 1
0088  D005      	BRA	label8
008A  51CD      	MOVF gbl_delivery_bytes_to_send+D'1', W, 1
008C  63D1      	CPFSEQ gbl_delivery_bytes_sent+D'1', 1
008E  D002      	BRA	label8
0090            label7

		control_mode = cm_CTRL_READ_AWAITING_STATUS;	// we're done with data stage
0090  0E05      	MOVLW 0x05
0092  6FE2      	MOVWF gbl_control_mode, 1

	}

	bd0in_count = count;
0094  0102      	MOVLB 0x02
0096  5131      	MOVF usb_send_d_0007A_1_count, W, 1
0098  6F05      	MOVWF gbl_bd0in+D'1', 1

	bd0in_addr = (uns16)&buffer_0_in;
009A  0E02      	MOVLW HIGH(gbl_buffer_0_in+D'0')
009C  6F07      	MOVWF gbl_bd0in+D'3', 1
009E  0E88      	MOVLW LOW(gbl_buffer_0_in+D'0')
00A0  6F06      	MOVWF gbl_bd0in+D'2', 1

	if (test_bit(bd0in_stat, DTS))
00A2  AD04      	BTFSS gbl_bd0in,6, 1
00A4  D002      	BRA	label9
00AA            label9

		clear_bit(bd0in_stat, DTS);
00A6  9D04      	BCF gbl_bd0in,6, 1

	else set_bit(bd0in_stat, DTS);
00A8  D001      	BRA	label10
00AA  8D04      	BSF gbl_bd0in,6, 1
00AC            label10

	clear_bit(bd0in_stat, KEN);		// clear the keep bit
00AC  9B04      	BCF gbl_bd0in,5, 1

	clear_bit(bd0in_stat, INCDIS);	// clear the increment disable
00AE  9904      	BCF gbl_bd0in,4, 1

	set_bit  (bd0in_stat, DTSEN);
00B0  8704      	BSF gbl_bd0in,3, 1

	clear_bit(bd0in_stat, BSTALL);	// clear stall bit
00B2  9504      	BCF gbl_bd0in,2, 1

	clear_bit(bd0in_stat, BC9);
00B4  9304      	BCF gbl_bd0in,1, 1

	clear_bit(bd0in_stat, BC8);
00B6  9104      	BCF gbl_bd0in,0, 1


	set_bit  (bd0in_stat, UOWN);	// SIE owns the buffer
00B8  8F04      	BSF gbl_bd0in,7, 1

}
00BA  0012      	RETURN



void usb_send_empty_data_pkt()

{
	delivery_buffer_size = USB_EP0_IN_SIZE;
0110  0102      	MOVLB 0x02
0112  6F2F      	MOVWF usb_send_e_00079_1___retpointvar, 1
0114  0E08      	MOVLW 0x08
0116  0101      	MOVLB 0x01
0118  6FE8      	MOVWF gbl_delivery_buffer_size, 1

	delivery_buffer = &buffer_0_in;
011A  0E02      	MOVLW HIGH(gbl_buffer_0_in+D'0')
011C  6FD5      	MOVWF gbl_delivery_buffer+D'1', 1
011E  0E88      	MOVLW LOW(gbl_buffer_0_in+D'0')
0120  6FD4      	MOVWF gbl_delivery_buffer, 1

	delivery_bytes_sent = 0;
0122  6BD0      	CLRF gbl_delivery_bytes_sent, 1
0124  6BD1      	CLRF gbl_delivery_bytes_sent+D'1', 1

	delivery_bytes_to_send = 0;
0126  6BCC      	CLRF gbl_delivery_bytes_to_send, 1
0128  6BCD      	CLRF gbl_delivery_bytes_to_send+D'1', 1

	delivery_bytes_max_send = 0;
012A  6BCE      	CLRF gbl_delivery_bytes_max_send, 1
012C  6BCF      	CLRF gbl_delivery_bytes_max_send+D'1', 1

	delivery_ptr = (uns8 *) 0;
012E  6BD2      	CLRF gbl_delivery_ptr, 1
0130  6BD3      	CLRF gbl_delivery_ptr+D'1', 1

	clear_bit(bd0in_stat, DTS);		// ready to get toggled
0132  0102      	MOVLB 0x02
0134  9D04      	BCF gbl_bd0in,6, 1

	usb_send_data_chunk();
0136  EC09F000  	CALL usb_send_d_0007A

}
013A  D000      	BRA	label13
013C            label13
013C  0E01      	MOVLW	HIGH( label14 )
013E  6EFA      	MOVWF PCLATH
0140  512F      	MOVF usb_send_e_00079_1___retpointvar, W, 1
0142  26F9      	ADDWF PCL, F
0144            label14
0144  EF54F003  	GOTO	label68
0148  EF3BF003  	GOTO	label67
014C  EFF1F002  	GOTO	label53
0150  EFFBF002  	GOTO	label55


uns8 buffer_byte;

void usb_send_one_byte(uns8 data)

{
	delivery_buffer_size = USB_EP0_IN_SIZE;
00C8  6F30      	MOVWF usb_send_o_0008C_1___retpointvar, 1
00CA  0E08      	MOVLW 0x08
00CC  0101      	MOVLB 0x01
00CE  6FE8      	MOVWF gbl_delivery_buffer_size, 1

	delivery_bytes_sent = 0;
00D0  6BD0      	CLRF gbl_delivery_bytes_sent, 1
00D2  6BD1      	CLRF gbl_delivery_bytes_sent+D'1', 1

	delivery_bytes_to_send = 1;
00D4  0E01      	MOVLW 0x01
00D6  6FCC      	MOVWF gbl_delivery_bytes_to_send, 1
00D8  6BCD      	CLRF gbl_delivery_bytes_to_send+D'1', 1

	delivery_bytes_max_send = 0;
00DA  6BCE      	CLRF gbl_delivery_bytes_max_send, 1
00DC  6BCF      	CLRF gbl_delivery_bytes_max_send+D'1', 1

	buffer_byte = data;
00DE  0102      	MOVLB 0x02
00E0  512F      	MOVF usb_send_o_0008C_arg_data, W, 1
00E2  0101      	MOVLB 0x01
00E4  6FEA      	MOVWF gbl_buffer_byte, 1

	delivery_ptr = (uns8 *) &buffer_byte;
00E6  0E01      	MOVLW HIGH(gbl_buffer_byte+D'0')
00E8  6FD3      	MOVWF gbl_delivery_ptr+D'1', 1
00EA  0EEA      	MOVLW LOW(gbl_buffer_byte+D'0')
00EC  6FD2      	MOVWF gbl_delivery_ptr, 1

	delivery_buffer = &buffer_0_in;
00EE  0E02      	MOVLW HIGH(gbl_buffer_0_in+D'0')
00F0  6FD5      	MOVWF gbl_delivery_buffer+D'1', 1
00F2  0E88      	MOVLW LOW(gbl_buffer_0_in+D'0')
00F4  6FD4      	MOVWF gbl_delivery_buffer, 1


	clear_bit(bd0in_stat, DTS);		// ready to get toggled
00F6  0102      	MOVLB 0x02
00F8  9D04      	BCF gbl_bd0in,6, 1

	usb_send_data_chunk();
00FA  EC09F000  	CALL usb_send_d_0007A

}
00FE  D000      	BRA	label11
0100            label11
0100  0E01      	MOVLW	HIGH( label12 )
0102  6EFA      	MOVWF PCLATH
0104  5130      	MOVF usb_send_o_0008C_1___retpointvar, W, 1
0106  26F9      	ADDWF PCL, F
0108            label12
0108  EF0CF003  	GOTO	label57
010C  EF11F003  	GOTO	label59


void usb_prime_ep0_out()

{
	bd0out_count = USB_EP0_OUT_SIZE;
052A  0E08      	MOVLW 0x08
052C  0102      	MOVLB 0x02
052E  6F01      	MOVWF gbl_bd0out+D'1', 1

	bd0out_addr = USB_EP0_OUT_ADDR;
0530  0E80      	MOVLW 0x80
0532  6F02      	MOVWF gbl_bd0out+D'2', 1
0534  0E02      	MOVLW 0x02
0536  6F03      	MOVWF gbl_bd0out+D'3', 1

	set_bit(bd0out_stat, DTS);		// turn on data togle sync TOGGLE
0538  8D00      	BSF gbl_bd0out,6, 1

	clear_bit(bd0out_stat, KEN);	// clear the keep bit
053A  9B00      	BCF gbl_bd0out,5, 1

	clear_bit(bd0out_stat, INCDIS);	// clear the increment disable
053C  9900      	BCF gbl_bd0out,4, 1

	set_bit  (bd0out_stat, DTSEN);
053E  8700      	BSF gbl_bd0out,3, 1

	clear_bit(bd0out_stat, BSTALL);	// clear stall bit
0540  9500      	BCF gbl_bd0out,2, 1

	clear_bit(bd0out_stat, BC9);
0542  9300      	BCF gbl_bd0out,1, 1

	clear_bit(bd0out_stat, BC8);
0544  9100      	BCF gbl_bd0out,0, 1


	set_bit  (bd0out_stat, UOWN);	// SIE owns the buffer
0546  8F00      	BSF gbl_bd0out,7, 1

}
0548  0012      	RETURN


void usb_handle_standard_request(setup_data_packet sdp)

{
	switch (sdp.bRequest)
0628            label61

	{
		case req_Get_Descriptor:
054A  0E06      	MOVLW 0x06
054C  6326      	CPFSEQ usb_handle_0008E_arg_sdp+D'1', 1
054E  D001      	BRA	label45
0550  D00F      	BRA	label49
0552            label45
0570            label49

			uns8 descriptor_type = sdp.wValue >> 8; 	// high byte is descriptor
0570  5128      	MOVF usb_handle_0008E_arg_sdp+D'3', W, 1
0572  6F2D      	MOVWF usb_handle_0008E_1_descrip_0008F, 1

			uns8 descriptor_num  = sdp.wValue & 0xff; 	// low byte is particular descriptor
0574  5127      	MOVF usb_handle_0008E_arg_sdp+D'2', W, 1
0576  6F2E      	MOVWF usb_handle_0008E_1_descrip_00090, 1


			usb_get_descriptor_callback(descriptor_type, descriptor_num, &delivery_ptr, &delivery_bytes_to_send);
0578  512D      	MOVF usb_handle_0008E_1_descrip_0008F, W, 1
057A  6F2F      	MOVWF usb_get_de_00080_arg_descr_00081, 1
057C  512E      	MOVF usb_handle_0008E_1_descrip_00090, W, 1
057E  6F30      	MOVWF usb_get_de_00080_arg_descr_00082, 1
0580  0E01      	MOVLW HIGH(gbl_delivery_ptr+D'0')
0582  6F32      	MOVWF usb_get_de_00080_arg_rtn_d_00083+D'1', 1
0584  0ED2      	MOVLW LOW(gbl_delivery_ptr+D'0')
0586  6F31      	MOVWF usb_get_de_00080_arg_rtn_d_00083, 1
0588  0E01      	MOVLW HIGH(gbl_delivery_bytes_to_send+D'0')
058A  6F34      	MOVWF usb_get_de_00080_arg_rtn_d_00084+D'1', 1
058C  0ECC      	MOVLW LOW(gbl_delivery_bytes_to_send+D'0')
058E  6F33      	MOVWF usb_get_de_00080_arg_rtn_d_00084, 1
0590  EC5CF001  	CALL usb_get_de_00080

			if (delivery_ptr != 0)
0594  0101      	MOVLB 0x01
0596  53D2      	MOVF gbl_delivery_ptr, F, 1
0598  E102      	BNZ	label50
059A  53D3      	MOVF gbl_delivery_ptr+D'1', F, 1
059C  E017      	BZ	label51
059E            label50
05CC            label51

			{	// we've got something
				control_mode = cm_CTRL_READ_DATA_STAGE;
059E  0E03      	MOVLW 0x03
05A0  6FE2      	MOVWF gbl_control_mode, 1

				delivery_bytes_max_send = sdp.wLength;	// maximum host wants
05A2  0102      	MOVLB 0x02
05A4  512B      	MOVF usb_handle_0008E_arg_sdp+D'6', W, 1
05A6  0101      	MOVLB 0x01
05A8  6FCE      	MOVWF gbl_delivery_bytes_max_send, 1
05AA  0102      	MOVLB 0x02
05AC  512C      	MOVF usb_handle_0008E_arg_sdp+D'7', W, 1
05AE  0101      	MOVLB 0x01
05B0  6FCF      	MOVWF gbl_delivery_bytes_max_send+D'1', 1

				delivery_bytes_sent = 0;				// clear our sent countr
05B2  6BD0      	CLRF gbl_delivery_bytes_sent, 1
05B4  6BD1      	CLRF gbl_delivery_bytes_sent+D'1', 1

				delivery_buffer_size = USB_EP0_IN_SIZE;
05B6  0E08      	MOVLW 0x08
05B8  6FE8      	MOVWF gbl_delivery_buffer_size, 1

				delivery_buffer = (uns8 *)USB_EP0_IN_ADDR;
05BA  0E88      	MOVLW 0x88
05BC  6FD4      	MOVWF gbl_delivery_buffer, 1
05BE  0E02      	MOVLW 0x02
05C0  6FD5      	MOVWF gbl_delivery_buffer+D'1', 1

				clear_bit(bd0in_stat, DTS);				// ready to get toggled
05C2  0102      	MOVLB 0x02
05C4  9D04      	BCF gbl_bd0in,6, 1

				usb_send_data_chunk();
05C6  EC09F000  	CALL usb_send_d_0007A

			}
			else
05CA  D02E      	BRA	label61

			{
				usb_stall_ep0();
05CC  EC5EF000  	CALL usb_stall__0007B

			}

			break;
05D0  D02B      	BRA	label61

		case req_Set_Address:
0552  0E05      	MOVLW 0x05
0554  6326      	CPFSEQ usb_handle_0008E_arg_sdp+D'1', 1
0556  D001      	BRA	label46
0558  D03C      	BRA	label52
055A            label46
05D2            label52

			usb_address = sdp.wValue & 0xff;
05D2  5127      	MOVF usb_handle_0008E_arg_sdp+D'2', W, 1
05D4  0101      	MOVLB 0x01
05D6  6FE1      	MOVWF gbl_usb_address, 1

			usb_status = us_SET_ADDRESS;
05D8  0E01      	MOVLW 0x01
05DA  6FE9      	MOVWF gbl_usb_status, 1


			// Send a status ack - when we confirm that, THEN change address
			usb_send_status_ack();
05DC  0E08      	MOVLW 0x08
05DE  EF88F000  	GOTO	usb_send_e_00079
05E2            label53

			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
05E2  0E06      	MOVLW 0x06
05E4  0101      	MOVLB 0x01
05E6  6FE2      	MOVWF gbl_control_mode, 1

			break;
05E8  D01F      	BRA	label61

		case req_Set_Configuration:
055A  0E09      	MOVLW 0x09
055C  6326      	CPFSEQ usb_handle_0008E_arg_sdp+D'1', 1
055E  D001      	BRA	label47
0560  D044      	BRA	label54
0562            label47
05EA            label54

			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
05EA  0E06      	MOVLW 0x06
05EC  0101      	MOVLB 0x01
05EE  6FE2      	MOVWF gbl_control_mode, 1

			usb_send_status_ack();
05F0  0E0C      	MOVLW 0x0C
05F2  EF88F000  	GOTO	usb_send_e_00079
05F6            label55

			usb_state = st_CONFIGURED;
05F6  0E03      	MOVLW 0x03
05F8  0101      	MOVLB 0x01
05FA  6FE0      	MOVWF gbl_usb_state, 1

			// device is up - so now get the endpoints happy
			usb_configure_endpoints();
05FC  ECC2F001  	CALL usb_config_0008B

			// and do a call back to let the app know we're ready
			#ifdef USB_CALLBACK_ON_DEVICE_CONFIGURED
				usb_device_configured_callback();
0600  ECBEF001  	CALL usb_device_0008A

			#endif
			break;
0604  D011      	BRA	label61

		case req_Get_Interface:
0562  0E0A      	MOVLW 0x0A
0564  6326      	CPFSEQ usb_handle_0008E_arg_sdp+D'1', 1
0566  D001      	BRA	label48
0568  D04E      	BRA	label56
056A            label48
0606            label56

				control_mode = cm_CTRL_READ_DATA_STAGE;
0606  0E03      	MOVLW 0x03
0608  0101      	MOVLB 0x01
060A  6FE2      	MOVWF gbl_control_mode, 1

				usb_send_one_byte(1);
060C  0E01      	MOVLW 0x01
060E  0102      	MOVLB 0x02
0610  6F2F      	MOVWF usb_send_o_0008C_arg_data, 1
0612  0E00      	MOVLW 0x00
0614  EF64F000  	GOTO	usb_send_o_0008C
0618            label57

				break;
0618  D007      	BRA	label61

		case req_Get_Status:
056A  5326      	MOVF usb_handle_0008E_arg_sdp+D'1', F, 1
056C  E056      	BZ	label58
061A            label58

				#ifdef USB_SELF_POWERED
					usb_send_one_byte(1);
				#else
					usb_send_one_byte(0);	// bus powered
061A  6B2F      	CLRF usb_send_o_0008C_arg_data, 1
061C  0E04      	MOVLW 0x04
061E  EF64F000  	GOTO	usb_send_o_0008C
0622            label59

				#endif
				break;
0622  D002      	BRA	label61

		default:
056E  D05A      	BRA	label60
0624            label60

			usb_stall_ep0();
0624  EC5EF000  	CALL usb_stall__0007B

			break;

	}
}
0628  EF1EF004  	GOTO	label77



void usb_handle_transaction()

{
	uns8 end_point, pid;
	end_point = ustat >> 3;
0780  3063      	RRCF gbl_ustat, W
0782  0102      	MOVLB 0x02
0784  6F20      	MOVWF usb_handle_00073_1_end_point, 1
0786  3320      	RRCF usb_handle_00073_1_end_point, F, 1
0788  3320      	RRCF usb_handle_00073_1_end_point, F, 1
078A  0E1F      	MOVLW 0x1F
078C  1720      	ANDWF usb_handle_00073_1_end_point, F, 1


	//read USTAT for endpoint information
	if (test_bit(ustat, DIR))
078E  A463      	BTFSS gbl_ustat,2
0790  D008      	BRA	label75
07A2            label75

	{
		pid = (bd0in_stat >> 2) & 0x0f;		// mask out pid
0792  3104      	RRCF gbl_bd0in, W, 1
0794  6F21      	MOVWF usb_handle_00073_1_pid, 1
0796  3321      	RRCF usb_handle_00073_1_pid, F, 1
0798  0E3F      	MOVLW 0x3F
079A  1721      	ANDWF usb_handle_00073_1_pid, F, 1
079C  0E0F      	MOVLW 0x0F
079E  1721      	ANDWF usb_handle_00073_1_pid, F, 1

	}
	else
07A0  D008      	BRA	label76
07B2            label76
0966  D009      	BRA	label98
09A6  D023      	BRA	label106

	{
		pid = (bd0out_stat >> 2) & 0x0f;	// mask out pid
07A2  3100      	RRCF gbl_bd0out, W, 1
07A4  6F22      	MOVWF CompTempVar2702, 1
07A6  3322      	RRCF CompTempVar2702, F, 1
07A8  0E3F      	MOVLW 0x3F
07AA  1722      	ANDWF CompTempVar2702, F, 1
07AC  0E0F      	MOVLW 0x0F
07AE  1522      	ANDWF CompTempVar2702, W, 1
07B0  6F21      	MOVWF usb_handle_00073_1_pid, 1

	}

	if (end_point == 0)
07B2  5320      	MOVF usb_handle_00073_1_end_point, F, 1
07B4  A4D8      	BTFSS STATUS,Z
07B6  D0C9      	BRA	label92
094A            label92

	{
		if (pid == pid_SETUP)
07B8  0E0D      	MOVLW 0x0D
07BA  6321      	CPFSEQ usb_handle_00073_1_pid, 1
07BC  D06E      	BRA	label80
089A            label80

		{
			memcpy(/*dst*/ (void*)&usb_sdp, /*src*/ (void *)&buffer_0_out, 8);
07BE  0E01      	MOVLW HIGH(gbl_usb_sdp+D'0')
07C0  6F29      	MOVWF memcpy8_00000_arg_dst+D'1', 1
07C2  0E5F      	MOVLW LOW(gbl_usb_sdp+D'0')
07C4  6F28      	MOVWF memcpy8_00000_arg_dst, 1
07C6  0E02      	MOVLW HIGH(gbl_buffer_0_out+D'0')
07C8  6F2B      	MOVWF memcpy8_00000_arg_src+D'1', 1
07CA  0E80      	MOVLW LOW(gbl_buffer_0_out+D'0')
07CC  6F2A      	MOVWF memcpy8_00000_arg_src, 1
07CE  0E08      	MOVLW 0x08
07D0  6F2C      	MOVWF memcpy8_00000_arg_len, 1
07D2  EC73F002  	CALL memcpy8_00000

			usb_prime_ep0_out();
07D6  EC95F002  	CALL usb_prime__0008D


			if (!test_bit(usb_sdp.bmRequestType, REQUEST_TYPE1) && // std request
07DA  0E40      	MOVLW 0x40
07DC  0101      	MOVLB 0x01
07DE  155F      	ANDWF gbl_usb_sdp, W, 1
07E0  0102      	MOVLB 0x02
07E2  6F22      	MOVWF CompTempVar2705, 1
07E4  6722      	TSTFSZ CompTempVar2705, 1
07E6  D02B      	BRA	label78
083E            label78

				!test_bit(usb_sdp.bmRequestType, REQUEST_TYPE0)) {
07E8  0E20      	MOVLW 0x20
07EA  0101      	MOVLB 0x01
07EC  155F      	ANDWF gbl_usb_sdp, W, 1
07EE  0102      	MOVLB 0x02
07F0  6F23      	MOVWF CompTempVar2706, 1
07F2  6723      	TSTFSZ CompTempVar2706, 1
07F4  D024      	BRA	label78

				usb_handle_standard_request(usb_sdp);
07F6  0101      	MOVLB 0x01
07F8  5166      	MOVF gbl_usb_sdp+D'7', W, 1
07FA  0102      	MOVLB 0x02
07FC  6F2C      	MOVWF usb_handle_0008E_arg_sdp+D'7', 1
07FE  0101      	MOVLB 0x01
0800  5165      	MOVF gbl_usb_sdp+D'6', W, 1
0802  0102      	MOVLB 0x02
0804  6F2B      	MOVWF usb_handle_0008E_arg_sdp+D'6', 1
0806  0101      	MOVLB 0x01
0808  5164      	MOVF gbl_usb_sdp+D'5', W, 1
080A  0102      	MOVLB 0x02
080C  6F2A      	MOVWF usb_handle_0008E_arg_sdp+D'5', 1
080E  0101      	MOVLB 0x01
0810  5163      	MOVF gbl_usb_sdp+D'4', W, 1
0812  0102      	MOVLB 0x02
0814  6F29      	MOVWF usb_handle_0008E_arg_sdp+D'4', 1
0816  0101      	MOVLB 0x01
0818  5162      	MOVF gbl_usb_sdp+D'3', W, 1
081A  0102      	MOVLB 0x02
081C  6F28      	MOVWF usb_handle_0008E_arg_sdp+D'3', 1
081E  0101      	MOVLB 0x01
0820  5161      	MOVF gbl_usb_sdp+D'2', W, 1
0822  0102      	MOVLB 0x02
0824  6F27      	MOVWF usb_handle_0008E_arg_sdp+D'2', 1
0826  0101      	MOVLB 0x01
0828  5160      	MOVF gbl_usb_sdp+D'1', W, 1
082A  0102      	MOVLB 0x02
082C  6F26      	MOVWF usb_handle_0008E_arg_sdp+D'1', 1
082E  0101      	MOVLB 0x01
0830  515F      	MOVF gbl_usb_sdp, W, 1
0832  0102      	MOVLB 0x02
0834  6F25      	MOVWF usb_handle_0008E_arg_sdp, 1
0836  0E99      	MOVLW 0x99
0838  EFA5F002  	GOTO	usb_handle_0008E
083C            label77

			}
			else if (!test_bit(usb_sdp.bmRequestType, REQUEST_TYPE1) && // class request
083C  D02C      	BRA	label79
083E  0E40      	MOVLW 0x40
0840  0101      	MOVLB 0x01
0842  155F      	ANDWF gbl_usb_sdp, W, 1
0844  0102      	MOVLB 0x02
0846  6F24      	MOVWF CompTempVar2708, 1
0848  6724      	TSTFSZ CompTempVar2708, 1
084A  D025      	BRA	label79

				test_bit(usb_sdp.bmRequestType, REQUEST_TYPE0)) {
084C  0101      	MOVLB 0x01
084E  AB5F      	BTFSS gbl_usb_sdp,5, 1
0850  D022      	BRA	label79

				#ifdef USB_CALLBACK_ON_CTRL_CLASS
					usb_handle_class_request(usb_sdp);
0852  5166      	MOVF gbl_usb_sdp+D'7', W, 1
0854  0102      	MOVLB 0x02
0856  6F2C      	MOVWF usb_handle_0007F_arg_sdp+D'7', 1
0858  0101      	MOVLB 0x01
085A  5165      	MOVF gbl_usb_sdp+D'6', W, 1
085C  0102      	MOVLB 0x02
085E  6F2B      	MOVWF usb_handle_0007F_arg_sdp+D'6', 1
0860  0101      	MOVLB 0x01
0862  5164      	MOVF gbl_usb_sdp+D'5', W, 1
0864  0102      	MOVLB 0x02
0866  6F2A      	MOVWF usb_handle_0007F_arg_sdp+D'5', 1
0868  0101      	MOVLB 0x01
086A  5163      	MOVF gbl_usb_sdp+D'4', W, 1
086C  0102      	MOVLB 0x02
086E  6F29      	MOVWF usb_handle_0007F_arg_sdp+D'4', 1
0870  0101      	MOVLB 0x01
0872  5162      	MOVF gbl_usb_sdp+D'3', W, 1
0874  0102      	MOVLB 0x02
0876  6F28      	MOVWF usb_handle_0007F_arg_sdp+D'3', 1
0878  0101      	MOVLB 0x01
087A  5161      	MOVF gbl_usb_sdp+D'2', W, 1
087C  0102      	MOVLB 0x02
087E  6F27      	MOVWF usb_handle_0007F_arg_sdp+D'2', 1
0880  0101      	MOVLB 0x01
0882  5160      	MOVF gbl_usb_sdp+D'1', W, 1
0884  0102      	MOVLB 0x02
0886  6F26      	MOVWF usb_handle_0007F_arg_sdp+D'1', 1
0888  0101      	MOVLB 0x01
088A  515F      	MOVF gbl_usb_sdp, W, 1
088C  0102      	MOVLB 0x02
088E  6F25      	MOVWF usb_handle_0007F_arg_sdp, 1
0890  0E99      	MOVLW 0x99
0892  EF16F003  	GOTO	usb_handle_0007F
0896            label79

				#endif
			}
			clear_bit(ucon, PKTDIS);
0896  9864      	BCF gbl_ucon,4

		}
		else if (pid == pid_IN)
0898  D0F0      	BRA	label108
089A  0E09      	MOVLW 0x09
089C  6321      	CPFSEQ usb_handle_00073_1_pid, 1
089E  D021      	BRA	label84
08E2            label84

		{
			if (control_mode == cm_CTRL_READ_DATA_STAGE)
08A0  0E03      	MOVLW 0x03
08A2  0101      	MOVLB 0x01
08A4  63E2      	CPFSEQ gbl_control_mode, 1
08A6  D003      	BRA	label81
08AE            label81

			{
				// it's ours, so send next chunk
				usb_send_data_chunk();
08A8  EC09F000  	CALL usb_send_d_0007A

			}
			else if (control_mode == cm_CTRL_WRITE_SENDING_STATUS)
08AC  D0E6      	BRA	label108
08AE  0E06      	MOVLW 0x06
08B0  63E2      	CPFSEQ gbl_control_mode, 1
08B2  D00C      	BRA	label82
08CC            label82

			{
				control_mode = cm_IDLE;
08B4  6BE2      	CLRF gbl_control_mode, 1

				if (usb_status == us_SET_ADDRESS)
08B6  05E9      	DECF gbl_usb_status, W, 1
08B8  A4D8      	BTFSS STATUS,Z
08BA  D0DF      	BRA	label108

				{
					usb_state = st_ADDRESS;
08BC  0E02      	MOVLW 0x02
08BE  6FE0      	MOVWF gbl_usb_state, 1

					uaddr = usb_address;
08C0  51E1      	MOVF gbl_usb_address, W, 1
08C2  010F      	MOVLB 0x0F
08C4  6F5C      	MOVWF gbl_uaddr, 1

					usb_status = us_IDLE;
08C6  0101      	MOVLB 0x01
08C8  6BE9      	CLRF gbl_usb_status, 1

				}
			}
			else if (control_mode == cm_CTRL_READ_AWAITING_STATUS)
08CA  D0D7      	BRA	label108
08CC  0E05      	MOVLW 0x05
08CE  63E2      	CPFSEQ gbl_control_mode, 1
08D0  D002      	BRA	label83
08D6            label83

			{
				// Must have been last IN of the read, so still waiting for status
				nop(); // boostc bug
08D2  0000      	NOP

			}
			else if (control_mode == cm_CTRL_READ_DATA_STAGE_CLASS)
08D4  D0D2      	BRA	label108
08D6  0E04      	MOVLW 0x04
08D8  63E2      	CPFSEQ gbl_control_mode, 1
08DA  D0CF      	BRA	label108

			{
				// Must be more to come
				#ifdef USB_CALLBACK_ON_CTRL_CLASS
					usb_handle_ctrl_read_class();
08DC  EC5AF003  	CALL usb_handle_0007D

				#else
					nop(); // otherwise boostc bug
				#endif
			}
		}
		else if (pid == pid_ACK)
08E0  D0CC      	BRA	label108
08E2  0E02      	MOVLW 0x02
08E4  6321      	CPFSEQ usb_handle_00073_1_pid, 1
08E6  D012      	BRA	label87
090C            label87

		{
			if (control_mode == cm_CTRL_READ_DATA_STAGE)
08E8  0E03      	MOVLW 0x03
08EA  0101      	MOVLB 0x01
08EC  63E2      	CPFSEQ gbl_control_mode, 1
08EE  D003      	BRA	label85
08F6            label85

			{
				usb_send_data_chunk();
08F0  EC09F000  	CALL usb_send_d_0007A

			}
			else if (control_mode == cm_CTRL_READ_DATA_STAGE_CLASS)
08F4  D0C2      	BRA	label108
08F6  0E04      	MOVLW 0x04
08F8  63E2      	CPFSEQ gbl_control_mode, 1
08FA  D003      	BRA	label86
0902            label86

			{
				#ifdef USB_CALLBACK_ON_CTRL_CLASS
					usb_handle_ctrl_read_class();
08FC  EC5AF003  	CALL usb_handle_0007D

				#else
					nop(); // boostc bug
				#endif
			}
			else if (control_mode == cm_CTRL_WRITE_SENDING_STATUS)
0900  D0BC      	BRA	label108
0902  0E06      	MOVLW 0x06
0904  63E2      	CPFSEQ gbl_control_mode, 1
0906  D0B9      	BRA	label108

			{
				control_mode = cm_IDLE;
0908  6BE2      	CLRF gbl_control_mode, 1

			}

		}
		else if (pid == pid_OUT)
090A  D0B7      	BRA	label108
090C  0521      	DECF usb_handle_00073_1_pid, W, 1
090E  A4D8      	BTFSS STATUS,Z
0910  D0B4      	BRA	label108

		{
			// We've done an out
			if (control_mode == cm_CTRL_READ_AWAITING_STATUS)
0912  0E05      	MOVLW 0x05
0914  0101      	MOVLB 0x01
0916  63E2      	CPFSEQ gbl_control_mode, 1
0918  D002      	BRA	label88
091E            label88

			{
				control_mode = cm_IDLE;
091A  6BE2      	CLRF gbl_control_mode, 1

			}
			else if (control_mode == cm_CTRL_WRITE_DATA_STAGE_CLASS)
091C  D013      	BRA	label91
091E  0E02      	MOVLW 0x02
0920  63E2      	CPFSEQ gbl_control_mode, 1
0922  D00C      	BRA	label90
093C            label90

			{
				#ifdef USB_CALLBACK_ON_CTRL_CLASS
					usb_handle_ctrl_write_class((uns8 *)&buffer_0_out, bd0out_count);
0924  0E02      	MOVLW HIGH(gbl_buffer_0_out+D'0')
0926  0102      	MOVLB 0x02
0928  6F23      	MOVWF usb_handle_0007E_arg_data+D'1', 1
092A  0E80      	MOVLW LOW(gbl_buffer_0_out+D'0')
092C  6F22      	MOVWF usb_handle_0007E_arg_data, 1
092E  5101      	MOVF gbl_bd0out+D'1', W, 1
0930  6F24      	MOVWF usb_handle_0007E_arg_count, 1
0932  6B25      	CLRF usb_handle_0007E_arg_count+D'1', 1
0934  0E99      	MOVLW 0x99
0936  EF3DF003  	GOTO	usb_handle_0007E
093A            label89

					// !! should include bc bits here for total count
				#else
					nop();
				#endif
			}
			else if (control_mode == cm_CTRL_READ_DATA_STAGE)
093A  D004      	BRA	label91
093C  0E03      	MOVLW 0x03
093E  63E2      	CPFSEQ gbl_control_mode, 1
0940  D001      	BRA	label91
0944            label91

			{
				control_mode = cm_IDLE;
0942  6BE2      	CLRF gbl_control_mode, 1

			}
			usb_prime_ep0_out();
0944  EC95F002  	CALL usb_prime__0008D

		}

	}
	else
0948  D098      	BRA	label108

	{
		buffer_descriptor *bd;
		if (test_bit(ustat, DIR))
094A  A463      	BTFSS gbl_ustat,2
094C  D021      	BRA	label101
0990            label101

		{
			// in
			#ifdef USB_EP_DATA_CALLBACK
#if 1 //defined(MX_USB_TYPE5) || defined (MX_USB_TYPE6)
				{
					uns8 count;
					switch (end_point) {
097E            label99

						case 0: count = bd0in_count;
094E  5320      	MOVF usb_handle_00073_1_end_point, F, 1
0950  E101      	BNZ	label93
0952  D00A      	BRA	label95
0954            label93
0968            label95
0968  5105      	MOVF gbl_bd0in+D'1', W, 1
096A  6F22      	MOVWF usb_handle_00073_88_count, 1

							break;
096C  D008      	BRA	label99

						case 1: count = bd1in_count;
0954  0520      	DECF usb_handle_00073_1_end_point, W, 1
0956  E00B      	BZ	label96
096E            label96
096E  510D      	MOVF gbl_bd1in+D'1', W, 1
0970  6F22      	MOVWF usb_handle_00073_88_count, 1

							break;
0972  D005      	BRA	label99

						case 2: count = bd2in_count;
0958  0E02      	MOVLW 0x02
095A  6320      	CPFSEQ usb_handle_00073_1_end_point, 1
095C  D001      	BRA	label94
095E  D00A      	BRA	label97
0960            label94
0974            label97
0974  5115      	MOVF gbl_bd2in+D'1', W, 1
0976  6F22      	MOVWF usb_handle_00073_88_count, 1

							break;
0978  D002      	BRA	label99

						case 3: count = bd3in_count;
0960  0E03      	MOVLW 0x03
0962  6320      	CPFSEQ usb_handle_00073_1_end_point, 1
0964  D00C      	BRA	label99
097A            label98
097A  511D      	MOVF gbl_bd3in+D'1', W, 1
097C  6F22      	MOVWF usb_handle_00073_88_count, 1

					}
					usb_ep_data_in_callback(end_point, count);
097E  5120      	MOVF usb_handle_00073_1_end_point, W, 1
0980  6F23      	MOVWF usb_ep_dat_00088_arg_end_point, 1
0982  5122      	MOVF usb_handle_00073_88_count, W, 1
0984  6F24      	MOVWF usb_ep_dat_00088_arg_byte_count, 1
0986  6B25      	CLRF usb_ep_dat_00088_arg_byte_count+D'1', 1
0988  0E99      	MOVLW 0x99
098A  EF61F003  	GOTO	usb_ep_dat_00088
098E            label100

				}
#else
				bd = ep_in_bd_location[end_point];
				usb_ep_data_in_callback(end_point, bd->count);
#endif
			#else
				nop();
			#endif
		}
		else
098E  D075      	BRA	label108
0A7A            label108

		{
			// out
#if 1 //defined(MX_USB_TYPE5) || defined (MX_USB_TYPE6)
			uns8 *bdstat;
			uns8 *bdcount;

			switch (end_point) {
0A06            label107

				case 0:
0990  5320      	MOVF usb_handle_00073_1_end_point, F, 1
0992  E00A      	BZ	label103
09A8            label103

					bdstat = &bd0out_stat;
09A8  0E02      	MOVLW HIGH(gbl_bd0out+D'0')
09AA  6F23      	MOVWF usb_handle_00073_97_bdstat+D'1', 1
09AC  0E00      	MOVLW LOW(gbl_bd0out+D'0')
09AE  6F22      	MOVWF usb_handle_00073_97_bdstat, 1

					bdcount = &bd0out_count;
09B0  0E02      	MOVLW HIGH(gbl_bd0out+D'1')
09B2  6F25      	MOVWF usb_handle_00073_97_bdcount+D'1', 1
09B4  0E01      	MOVLW LOW(gbl_bd0out+D'1')
09B6  6F24      	MOVWF usb_handle_00073_97_bdcount, 1

					break;
09B8  D026      	BRA	label107

				case 1:
0994  0520      	DECF usb_handle_00073_1_end_point, W, 1
0996  E011      	BZ	label104
09BA            label104

					bdstat = &bd1out_stat;
09BA  0E02      	MOVLW HIGH(gbl_bd1out+D'0')
09BC  6F26      	MOVWF CompTempVar2714, 1
09BE  0E08      	MOVLW LOW(gbl_bd1out+D'0')
09C0  6F22      	MOVWF usb_handle_00073_97_bdstat, 1
09C2  5126      	MOVF CompTempVar2714, W, 1
09C4  6F23      	MOVWF usb_handle_00073_97_bdstat+D'1', 1

					bdcount = &bd1out_count;
09C6  0E02      	MOVLW HIGH(gbl_bd1out+D'1')
09C8  6F26      	MOVWF CompTempVar2715, 1
09CA  0E09      	MOVLW LOW(gbl_bd1out+D'1')
09CC  6F24      	MOVWF usb_handle_00073_97_bdcount, 1
09CE  5126      	MOVF CompTempVar2715, W, 1
09D0  6F25      	MOVWF usb_handle_00073_97_bdcount+D'1', 1

					break;
09D2  D019      	BRA	label107

				case 2:
0998  0E02      	MOVLW 0x02
099A  6320      	CPFSEQ usb_handle_00073_1_end_point, 1
099C  D001      	BRA	label102
099E  D01A      	BRA	label105
09A0            label102
09D4            label105

					bdstat = &bd2out_stat;
09D4  0E02      	MOVLW HIGH(gbl_bd2out+D'0')
09D6  6F26      	MOVWF CompTempVar2716, 1
09D8  0E10      	MOVLW LOW(gbl_bd2out+D'0')
09DA  6F22      	MOVWF usb_handle_00073_97_bdstat, 1
09DC  5126      	MOVF CompTempVar2716, W, 1
09DE  6F23      	MOVWF usb_handle_00073_97_bdstat+D'1', 1

					bdcount = &bd2out_count;
09E0  0E02      	MOVLW HIGH(gbl_bd2out+D'1')
09E2  6F26      	MOVWF CompTempVar2717, 1
09E4  0E11      	MOVLW LOW(gbl_bd2out+D'1')
09E6  6F24      	MOVWF usb_handle_00073_97_bdcount, 1
09E8  5126      	MOVF CompTempVar2717, W, 1
09EA  6F25      	MOVWF usb_handle_00073_97_bdcount+D'1', 1

					break;
09EC  D00C      	BRA	label107

				case 3:
09A0  0E03      	MOVLW 0x03
09A2  6320      	CPFSEQ usb_handle_00073_1_end_point, 1
09A4  D030      	BRA	label107
09EE            label106

					bdstat = &bd3out_stat;
09EE  0E02      	MOVLW HIGH(gbl_bd3out+D'0')
09F0  6F26      	MOVWF CompTempVar2718, 1
09F2  0E18      	MOVLW LOW(gbl_bd3out+D'0')
09F4  6F22      	MOVWF usb_handle_00073_97_bdstat, 1
09F6  5126      	MOVF CompTempVar2718, W, 1
09F8  6F23      	MOVWF usb_handle_00073_97_bdstat+D'1', 1

					bdcount = &bd3out_count;
09FA  0E02      	MOVLW HIGH(gbl_bd3out+D'1')
09FC  6F26      	MOVWF CompTempVar2719, 1
09FE  0E19      	MOVLW LOW(gbl_bd3out+D'1')
0A00  6F24      	MOVWF usb_handle_00073_97_bdcount, 1
0A02  5126      	MOVF CompTempVar2719, W, 1
0A04  6F25      	MOVWF usb_handle_00073_97_bdcount+D'1', 1

			}
			#ifdef USB_EP_DATA_CALLBACK
				usb_ep_data_out_callback(end_point, ep_out_buffer_location[end_point],
0A06  5120      	MOVF usb_handle_00073_1_end_point, W, 1
0A08  6F26      	MOVWF usb_ep_dat_00087_arg_end_point, 1
0A0A  0101      	MOVLB 0x01
0A0C  EE01F06F  	LFSR 0x00, gbl_ep_out_buffer_location
0A10  50E9      	MOVF FSR0L, W
0A12  0102      	MOVLB 0x02
0A14  5120      	MOVF usb_handle_00073_1_end_point, W, 1
0A16  6F2B      	MOVWF CompTempVar2726, 1
0A18  90D8      	BCF STATUS,C
0A1A  352B      	RLCF CompTempVar2726, W, 1
0A1C  26E9      	ADDWF FSR0L, F
0A1E  50EE      	MOVF POSTINC0, W
0A20  6F27      	MOVWF usb_ep_dat_00087_arg_buffer, 1
0A22  50EF      	MOVF INDF0, W
0A24  6F28      	MOVWF usb_ep_dat_00087_arg_buffer+D'1', 1
0A2E  50EF      	MOVF INDF0, W
0A30  6F29      	MOVWF usb_ep_dat_00087_arg_byte_count, 1
0A32  6B2A      	CLRF usb_ep_dat_00087_arg_byte_count+D'1', 1
0A34  EC65F003  	CALL usb_ep_dat_00087

									*bdcount);
0A26  5125      	MOVF usb_handle_00073_97_bdcount+D'1', W, 1
0A28  6EEA      	MOVWF FSR0H
0A2A  5124      	MOVF usb_handle_00073_97_bdcount, W, 1
0A2C  6EE9      	MOVWF FSR0L

			#endif

			// re-prime endpoint
			*bdcount = ep_out_buffer_size[end_point];
0A38  0101      	MOVLB 0x01
0A3A  EE01F07F  	LFSR 0x00, gbl_ep_out_buffer_size
0A3E  50E9      	MOVF FSR0L, W
0A40  0102      	MOVLB 0x02
0A42  5120      	MOVF usb_handle_00073_1_end_point, W, 1
0A44  6F26      	MOVWF CompTempVar2729, 1
0A46  90D8      	BCF STATUS,C
0A48  3726      	RLCF CompTempVar2729, F, 1
0A4A  5126      	MOVF CompTempVar2729, W, 1
0A4C  26E9      	ADDWF FSR0L, F
0A4E  50EE      	MOVF POSTINC0, W
0A50  6F27      	MOVWF CompTempVar2731, 1
0A52  50EF      	MOVF INDF0, W
0A54  6F28      	MOVWF CompTempVar2731+D'1', 1
0A56  5125      	MOVF usb_handle_00073_97_bdcount+D'1', W, 1
0A58  6EEA      	MOVWF FSR0H
0A5A  5124      	MOVF usb_handle_00073_97_bdcount, W, 1
0A5C  6EE9      	MOVWF FSR0L
0A5E  5127      	MOVF CompTempVar2731, W, 1
0A60  6EEF      	MOVWF INDF0


			// Address shouldn't change, so don't need to update it

			clear_bit(*bdstat, DTS);		// turn on data togle sync TOGGLE
0A62  5123      	MOVF usb_handle_00073_97_bdstat+D'1', W, 1
0A64  6EEA      	MOVWF FSR0H
0A66  5122      	MOVF usb_handle_00073_97_bdstat, W, 1
0A68  6EE9      	MOVWF FSR0L
0A6A  9CEF      	BCF INDF0,6

			clear_bit(*bdstat, KEN);		// clear the keep bit
0A6C  9AEF      	BCF INDF0,5

			clear_bit(*bdstat, INCDIS);	// clear the increment disable
0A6E  98EF      	BCF INDF0,4

			clear_bit(*bdstat, DTSEN);
0A70  96EF      	BCF INDF0,3

			clear_bit(*bdstat, BSTALL);	// clear stall bit
0A72  94EF      	BCF INDF0,2

			clear_bit(*bdstat, BC9);
0A74  92EF      	BCF INDF0,1

			clear_bit(*bdstat, BC8);
0A76  90EF      	BCF INDF0,0

			set_bit  (*bdstat, UOWN);		// SIE owns the buffer
0A78  8EEF      	BSF INDF0,7

#else
			bd = ep_out_bd_location[end_point];
			// issue callback
			#ifdef USB_EP_DATA_CALLBACK
				usb_ep_data_out_callback(end_point, ep_out_buffer_location[end_point],
									bd->count);
			#endif
			// re-prime endpoint
			bd->count = ep_out_buffer_size[end_point];

			// Address shouldn't change, so don't need to update it

			clear_bit(bd->stat, DTS);		// turn on data togle sync TOGGLE
			clear_bit(bd->stat, KEN);		// clear the keep bit
			clear_bit(bd->stat, INCDIS);	// clear the increment disable
			clear_bit(bd->stat, DTSEN);
			clear_bit(bd->stat, BSTALL);	// clear stall bit
			clear_bit(bd->stat, BC9);
			clear_bit(bd->stat, BC8);
			set_bit  (bd->stat, UOWN);		// SIE owns the buffer
#endif
		}
	}
}
0A7A  EF4EF005  	GOTO	label110



void usb_handle_reset()

{
	usb_address = 0;
0736  0101      	MOVLB 0x01
0738  6BE1      	CLRF gbl_usb_address, 1

	//uaddr = 0;

	control_mode = cm_IDLE;
073A  6BE2      	CLRF gbl_control_mode, 1

	usb_status   = us_IDLE;
073C  6BE9      	CLRF gbl_usb_status, 1


	// clear fifo
	clear_bit(uir, TRNIF);
073E  9662      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
0740  9662      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
0742  9662      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
0744  9662      	BCF gbl_uir,3


	// init buffers

	// EP0 OUT
	bd0out_count = USB_EP0_OUT_SIZE;	// 8 byte buffer
0746  0E08      	MOVLW 0x08
0748  0102      	MOVLB 0x02
074A  6F01      	MOVWF gbl_bd0out+D'1', 1

	bd0out_addr = USB_EP0_OUT_ADDR;
074C  0E80      	MOVLW 0x80
074E  6F02      	MOVWF gbl_bd0out+D'2', 1
0750  0E02      	MOVLW 0x02
0752  6F03      	MOVWF gbl_bd0out+D'3', 1


	clear_bit(bd0out_stat, DTS);	// turn on data togle sync TOGGLE
0754  9D00      	BCF gbl_bd0out,6, 1

	clear_bit(bd0out_stat, KEN);	// clear the keep bit
0756  9B00      	BCF gbl_bd0out,5, 1

	clear_bit(bd0out_stat, INCDIS);	// clear the increment disable
0758  9900      	BCF gbl_bd0out,4, 1

	clear_bit  (bd0out_stat, DTSEN);	// !!!!!!
075A  9700      	BCF gbl_bd0out,3, 1

	clear_bit(bd0out_stat, BSTALL);	// clear stall bit
075C  9500      	BCF gbl_bd0out,2, 1

	clear_bit(bd0out_stat, BC9);
075E  9300      	BCF gbl_bd0out,1, 1

	clear_bit(bd0out_stat, BC8);
0760  9100      	BCF gbl_bd0out,0, 1


	set_bit  (bd0out_stat, UOWN);	// SIE owns the buffer
0762  8F00      	BSF gbl_bd0out,7, 1

					// since we expect frist transaction to be SETUP
	// EP0 IN
	bd0in_count = USB_EP0_IN_SIZE;	// 8 byte buffer
0764  0E08      	MOVLW 0x08
0766  6F05      	MOVWF gbl_bd0in+D'1', 1

	bd0in_addr = USB_EP0_IN_ADDR;
0768  0E88      	MOVLW 0x88
076A  6F06      	MOVWF gbl_bd0in+D'2', 1
076C  0E02      	MOVLW 0x02
076E  6F07      	MOVWF gbl_bd0in+D'3', 1

	clear_bit(bd0in_stat, DTS);	// turn on data togle sync TOGGLE
0770  9D04      	BCF gbl_bd0in,6, 1

	clear_bit(bd0in_stat, KEN);	// clear the keep bit
0772  9B04      	BCF gbl_bd0in,5, 1

	clear_bit(bd0in_stat, INCDIS);	// clear the increment disable
0774  9904      	BCF gbl_bd0in,4, 1

	clear_bit(bd0in_stat, BSTALL);	// clear stall bit
0776  9504      	BCF gbl_bd0in,2, 1

	clear_bit(bd0in_stat, BC9);
0778  9304      	BCF gbl_bd0in,1, 1

	clear_bit(bd0in_stat, BC8);
077A  9104      	BCF gbl_bd0in,0, 1


	clear_bit(bd0in_stat, UOWN);	// uC owns the buffer
077C  9F04      	BCF gbl_bd0in,7, 1

}
077E  0012      	RETURN



void usb_handle_stall()

{
}
0734  0012      	RETURN



void usb_handle_isr()

{
	if (test_bit(PIRREG, USBIF))			//USB Interrupt?
0A86  A4A1      	BTFSS gbl_pir2,2
0A88  D01F      	BRA	label115

	{
		clear_bit(PIRREG, USBIF);			//Clear USB Interrupt
0A8A  94A1      	BCF gbl_pir2,2


		if (test_bit(uir, IDLEIF))		//USB Idle Interrupt?
0A8C  A862      	BTFSS gbl_uir,4
0A8E  D001      	BRA	label109
0A92            label109

		{
			clear_bit(uir, IDLEIF);		//Clear Idle
0A90  9862      	BCF gbl_uir,4

		}

		if (test_bit(uir, TRNIF))		//USB Transaction detected?
0A92  A662      	BTFSS gbl_uir,3
0A94  D004      	BRA	label111
0A9E            label111

		{
			usb_handle_transaction();	//Handle the transaction
0A96  0E99      	MOVLW 0x99
0A98  EFC0F003  	GOTO	usb_handle_00073
0A9C            label110

			clear_bit(uir, TRNIF);		//Clear the interrupt
0A9C  9662      	BCF gbl_uir,3

		}

		if (test_bit(uir, URSTIF))		//USB Reset detected?
0A9E  A062      	BTFSS gbl_uir,0
0AA0  D003      	BRA	label112
0AA8            label112

		{
			usb_handle_reset();			//Deal with the reset
0AA2  EC9BF003  	CALL usb_handle_00074

			clear_bit(uir, URSTIF);		//Clear the interrupt
0AA6  9062      	BCF gbl_uir,0

		}

		if (test_bit(uir, STALLIF))		//USB Stall detected?
0AA8  AA62      	BTFSS gbl_uir,5
0AAA  D003      	BRA	label113
0AB2            label113

		{
			usb_handle_stall();			//Handle the stall
0AAC  EC9AF003  	CALL usb_handle_00075

			clear_bit(uir, STALLIF);	//Clear the interrupt
0AB0  9A62      	BCF gbl_uir,5

		}
		if (test_bit(uir, SOFIF))		//USB Start of frame detected?
0AB2  AC62      	BTFSS gbl_uir,6
0AB4  D009      	BRA	label115
0AC8            label115

		{
			#ifdef USB_CALLBACK_ON_SOF
				usb_SOF_callback(ufrml);	// sourceboost defines this
0AB6  010F      	MOVLB 0x0F
0AB8  515D      	MOVF gbl_ufrml, W, 1
0ABA  0102      	MOVLB 0x02
0ABC  6F20      	MOVWF usb_SOF_ca_00076_arg_frame, 1
0ABE  6B21      	CLRF usb_SOF_ca_00076_arg_frame+D'1', 1
0AC0  0E99      	MOVLW 0x99
0AC2  EF3FF005  	GOTO	usb_SOF_ca_00076
0AC6            label114

			#endif
 			clear_bit(uir, SOFIF);		//Clear the interrupt
0AC6  9C62      	BCF gbl_uir,6

		}
	}
}
0AC8  EF55F009  	GOTO	label140



void usb_setup()

{
	usb_state = st_POWERED;
0ACC  0101      	MOVLB 0x01
0ACE  6BE0      	CLRF gbl_usb_state, 1


	// init hardware
        #if (USB_DESCRIPTOR_ADDRESS != 0x2000)
	// JK: Bit is reserved for 16f1455 series, do not touch
        clear_bit(ucfg, 3);     // enable internal tranceiver   -- BR Modded from UTRDIS to 3 for K50 devices
0AD0  9661      	BCF gbl_ucfg,3

	#endif
	set_bit(ucfg, FSEN);	// clear for low speed, set for high speed
0AD2  8461      	BSF gbl_ucfg,2

	set_bit  (ucfg, UPUEN);	// enable on-chip pull-ups
0AD4  8861      	BSF gbl_ucfg,4


	clear_bit(ucfg, PPB1);	// disable double buffering for now
0AD6  9261      	BCF gbl_ucfg,1

	clear_bit(ucfg, PPB0);
0AD8  9061      	BCF gbl_ucfg,0


	// init endpoints
	set_bit(uep0,   EPHSHK);	// EP0 handshaking on
0ADA  010F      	MOVLB 0x0F
0ADC  8953      	BSF gbl_uep0,4, 1

	set_bit(uep0,   EPOUTEN);	// EP0 OUT enable
0ADE  8553      	BSF gbl_uep0,2, 1

	set_bit(uep0,   EPINEN); 	// EP0 IN enable
0AE0  8353      	BSF gbl_uep0,1, 1

	clear_bit(uep0, EPCONDIS);	// EP0 control transfers on (and IN and OUT)
0AE2  9753      	BCF gbl_uep0,3, 1


	// init interrupts
	set_bit(uie,  STALLIE);		// interrupt on stall
0AE4  8A60      	BSF gbl_uie,5

	set_bit(uie,  TRNIE);		// on transaction complete
0AE6  8660      	BSF gbl_uie,3

	set_bit(uie,  URSTIE);		// on reset
0AE8  8060      	BSF gbl_uie,0

	set_bit(PIEREG, USBIE);		// general USB interrupts
0AEA  84A0      	BSF gbl_pie2,2

	#ifdef USB_CALLBACK_ON_SOF
		set_bit(uie, SOFIE);
0AEC  8C60      	BSF gbl_uie,6

	#endif

}
0AEE  0012      	RETURN


void usb_enable_module()

{
	// enable usb module
	uir = 0;
0AF0  6A62      	CLRF gbl_uir

	set_bit(ucon, USBEN);		// enable USB serial interface engine (SIE)
0AF2  8664      	BSF gbl_ucon,3

	usb_state = st_DEFAULT;
0AF4  0E01      	MOVLW 0x01
0AF6  0101      	MOVLB 0x01
0AF8  6FE0      	MOVWF gbl_usb_state, 1

}
0AFA  0012      	RETURN



usb_state_type usb_get_state()
{
	return usb_state;
}

/*********************************************************************
 *                    Flowcode USB Component Code
 *
 * File: usb_cdc_class.c
 *
 * (c) 2009 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 031008 | BR | Created
 * 190711 | BR | Confirmed current version
 * 230614 | LM | Support for 18F45K50
 ********************************************************************/

// USB includes
#include "pic_usb.h"
#include "pic_usb_buffer_mgt.h"

// local includes
#include "usb_cdc_class.h"

// system includes
#include <memory.h>

// class definitions

#define req_SEND_ENCAPSULATED_COMMAND	0x00
#define req_GET_ENCAPSULATED_RESPONSE	0x01
#define	req_SET_COMM_FEATURE			0x02
#define req_GET_COMM_FEATURE			0x03
#define req_CLEAR_COMM_FEATURE			0x04
#define req_SET_LINE_CODING				0x20
#define req_GET_LINE_CODING				0x21
#define req_SET_CONTROL_LINE_STATE		0x22
#define req_SEND_BREAK					0x23

typedef  union _long_union{
		long as_long;
		uns8 as_byte_array[4];
} long_union;


typedef struct _line_coding {
	long_union	dte_rate;
	uns8	stop_bits;	// 0=1 stop bit, 1=1.5 stop bits, 2=2 stop bits
	uns8	parity;		// 0=None, 1=Odd, 2=Even, 3=Mark, 4=Space
	uns8	data_bits;	// 5,6,7,8 or 16 bits
}	line_coding;

/** Transmit fifo  */
uns8 cdc_tx_buffer[CDC_TX_BUFFER_SIZE];
/** Transmit fifo start point */
uns8 cdc_tx_start=0;
1276  6BEB      	CLRF gbl_cdc_tx_start, 1

/** Transmit fifo end point */
uns8 cdc_tx_end=0;
1278  6BEC      	CLRF gbl_cdc_tx_end, 1


/** Receive fifo */
uns8 cdc_rx_buffer[CDC_RX_BUFFER_SIZE];
/** Receive fifo start point */
uns8 cdc_rx_start = 0;
127A  6BED      	CLRF gbl_cdc_rx_start, 1

/** Receive fifo end point */
uns8 cdc_rx_end = 0;
127C  6BEE      	CLRF gbl_cdc_rx_end, 1



uns8 class_data[8];	// we'll dump all our class data in here

void usb_handle_class_request(setup_data_packet sdp) {


	switch (sdp.bRequest) {

		case req_SET_LINE_CODING:
062C  0E20      	MOVLW 0x20
062E  6326      	CPFSEQ usb_handle_0007F_arg_sdp+D'1', 1
0630  D001      	BRA	label62
0632  D008      	BRA	label64
0634            label62
0642  D013      	BRA	label66
0644            label64

			// we now expect the line coding to arrive in the data stage
			control_mode = cm_CTRL_WRITE_DATA_STAGE_CLASS;
0644  0E02      	MOVLW 0x02
0646  0101      	MOVLB 0x01
0648  6FE2      	MOVWF gbl_control_mode, 1

			break;
064A  D015      	BRA	label67

		case req_GET_LINE_CODING:
0634  0E21      	MOVLW 0x21
0636  6326      	CPFSEQ usb_handle_0007F_arg_sdp+D'1', 1
0638  D001      	BRA	label63
063A  D008      	BRA	label65
063C            label63
064C            label65

			control_mode = cm_CTRL_READ_DATA_STAGE_CLASS;
064C  0E04      	MOVLW 0x04
064E  0101      	MOVLB 0x01
0650  6FE2      	MOVWF gbl_control_mode, 1

			//  need to prime ep0 IN with some funky data here
			usb_send_data(/*ep*/ 0, /*data*/ &class_data, /*count*/ 8, /*first*/ 1);
0652  0102      	MOVLB 0x02
0654  6B2D      	CLRF usb_send_d_00078_arg_ep, 1
0656  0E01      	MOVLW HIGH(gbl_class_data+D'0')
0658  6F2F      	MOVWF usb_send_d_00078_arg_data+D'1', 1
065A  0E87      	MOVLW LOW(gbl_class_data+D'0')
065C  6F2E      	MOVWF usb_send_d_00078_arg_data, 1
065E  0E08      	MOVLW 0x08
0660  6F30      	MOVWF usb_send_d_00078_arg_send_count, 1
0662  8131      	BSF usb_send_d_00078_arg_first,0, 1
0664  ECAAF000  	CALL usb_send_d_00078

			// actually we know this will be the last packet, so go straight to waiting for the status ack
			break;
0668  D006      	BRA	label67

		case req_SET_CONTROL_LINE_STATE:
063C  0E22      	MOVLW 0x22
063E  6326      	CPFSEQ usb_handle_0007F_arg_sdp+D'1', 1
0640  D01A      	BRA	label67
066A            label66

			// no data, so just ack the status
			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
066A  0E06      	MOVLW 0x06
066C  0101      	MOVLB 0x01
066E  6FE2      	MOVWF gbl_control_mode, 1

			usb_send_status_ack();
0670  0E04      	MOVLW 0x04
0672  EF88F000  	GOTO	usb_send_e_00079
0676            label67

			break;
		default:
	}
}
0676  EF4BF004  	GOTO	label79


void usb_handle_ctrl_write_class(uns8 *data, uns16 count) {


	switch (usb_sdp.bRequest) {
06B0            label69

		case req_SET_LINE_CODING:
067A  0E20      	MOVLW 0x20
067C  0101      	MOVLB 0x01
067E  6360      	CPFSEQ gbl_usb_sdp+D'1', 1
0680  D017      	BRA	label69

			// dump it into class_data
			memcpy(/* dst */ (void *)&class_data,/* src */ (void *)data, count);
0682  0E01      	MOVLW HIGH(gbl_class_data+D'0')
0684  0102      	MOVLB 0x02
0686  6F29      	MOVWF memcpy8_00000_arg_dst+D'1', 1
0688  0E87      	MOVLW LOW(gbl_class_data+D'0')
068A  6F28      	MOVWF memcpy8_00000_arg_dst, 1
068C  5122      	MOVF usb_handle_0007E_arg_data, W, 1
068E  6F2A      	MOVWF memcpy8_00000_arg_src, 1
0690  5123      	MOVF usb_handle_0007E_arg_data+D'1', W, 1
0692  6F2B      	MOVWF memcpy8_00000_arg_src+D'1', 1
0694  5124      	MOVF usb_handle_0007E_arg_count, W, 1
0696  6F2C      	MOVWF memcpy8_00000_arg_len, 1
0698  EC73F002  	CALL memcpy8_00000


			// Now we need to send an ACK status back
			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
069C  0E06      	MOVLW 0x06
069E  0101      	MOVLB 0x01
06A0  6FE2      	MOVWF gbl_control_mode, 1

			usb_send_status_ack();
06A2  0E00      	MOVLW 0x00
06A4  EF88F000  	GOTO	usb_send_e_00079
06A8            label68

			line_coding *my_lc;
			my_lc = (line_coding*) &class_data;
06A8  0E01      	MOVLW HIGH(gbl_class_data+D'0')
06AA  6F27      	MOVWF usb_handle_0007E_1_my_lc+D'1', 1
06AC  0E87      	MOVLW LOW(gbl_class_data+D'0')
06AE  6F26      	MOVWF usb_handle_0007E_1_my_lc, 1

			break;
	}
}
06B0  EF9DF004  	GOTO	label89


void usb_handle_ctrl_read_class()

{
		switch (usb_sdp.bRequest)
		{
			case req_GET_LINE_CODING:
06B4  0E21      	MOVLW 0x21
06B6  0101      	MOVLB 0x01
06B8  6360      	CPFSEQ gbl_usb_sdp+D'1', 1

				// we know we've already sent everything, so now wait for status
				control_mode = cm_CTRL_READ_AWAITING_STATUS;
06BC  0E05      	MOVLW 0x05
06BE  6FE2      	MOVWF gbl_control_mode, 1

				break;
			default:
		}

}
06BA  0012      	RETURN
06C0  0012      	RETURN


void usb_ep_data_out_callback(uns8 end_point, uns8 *buffer, uns16 byte_count)

{
	uns8 cdc_rx_next;

	// We have some data!
	if (end_point == CDC_DATA_ENDPOINT)
06CA  0E03      	MOVLW 0x03
06CC  6326      	CPFSEQ usb_ep_dat_00087_arg_end_point, 1

	{	// it's the data end point

		uns8 count;
		for (count = 0; count < byte_count; count++)
06D0  6B2C      	CLRF usb_ep_dat_00087_2_count, 1
06D2            label70
06D2  5129      	MOVF usb_ep_dat_00087_arg_byte_count, W, 1
06D4  612C      	CPFSLT usb_ep_dat_00087_2_count, 1
06D6  512A      	MOVF usb_ep_dat_00087_arg_byte_count+D'1', W, 1
06D8  B4D8      	BTFSC STATUS,Z
072E  0102      	MOVLB 0x02
0730  2B2C      	INCF usb_ep_dat_00087_2_count, F, 1
0732  D7CF      	BRA	label70

		{
			cdc_rx_next = cdc_rx_end + 1;	// get next buffer position
06DC  0101      	MOVLB 0x01
06DE  29EE      	INCF gbl_cdc_rx_end, W, 1
06E0  0102      	MOVLB 0x02
06E2  6F2B      	MOVWF usb_ep_dat_00087_1_cdc_rx_next, 1

			if (cdc_rx_next == CDC_RX_BUFFER_SIZE)
06E4  0E40      	MOVLW 0x40
06E6  632B      	CPFSEQ usb_ep_dat_00087_1_cdc_rx_next, 1
06E8  D001      	BRA	label71
06EC            label71

			{	// if we're at the end
				cdc_rx_next = 0;	// then wrap to the beginning
06EA  6B2B      	CLRF usb_ep_dat_00087_1_cdc_rx_next, 1

			}
			if (cdc_rx_next != cdc_rx_start)
06EC  0101      	MOVLB 0x01
06EE  51ED      	MOVF gbl_cdc_rx_start, W, 1
06F0  0102      	MOVLB 0x02
06F2  632B      	CPFSEQ usb_ep_dat_00087_1_cdc_rx_next, 1
06F4  D001      	BRA	label72
06F6  D002      	BRA	label73
06F8            label72
06F8  0101      	MOVLB 0x01
06FA  63ED      	CPFSEQ gbl_cdc_rx_start, 1
06FC            label73
06FC  D018      	BRA	label74
072E            label74

			{ // if space in the fifo
				cdc_rx_buffer[cdc_rx_end] = buffer[count]; // put it in
06FE  0102      	MOVLB 0x02
0700  5128      	MOVF usb_ep_dat_00087_arg_buffer+D'1', W, 1
0702  6EEA      	MOVWF FSR0H
0704  5127      	MOVF usb_ep_dat_00087_arg_buffer, W, 1
0706  6EE9      	MOVWF FSR0L
0708  512C      	MOVF usb_ep_dat_00087_2_count, W, 1
070A  6F2D      	MOVWF CompTempVar2772, 1
070C  512D      	MOVF CompTempVar2772, W, 1
070E  26E9      	ADDWF FSR0L, F
0710  50EF      	MOVF INDF0, W
0712  6F2E      	MOVWF CompTempVar2773, 1
0714  0100      	MOVLB 0x00
0716  EE00F0A0  	LFSR 0x00, gbl_cdc_rx_buffer
071A  50E9      	MOVF FSR0L, W
071C  0101      	MOVLB 0x01
071E  51EE      	MOVF gbl_cdc_rx_end, W, 1
0720  26E9      	ADDWF FSR0L, F
0722  0102      	MOVLB 0x02
0724  512E      	MOVF CompTempVar2773, W, 1
0726  6EEF      	MOVWF INDF0

				cdc_rx_end = cdc_rx_next;  // and move pointer along
0728  512B      	MOVF usb_ep_dat_00087_1_cdc_rx_next, W, 1
072A  0101      	MOVLB 0x01
072C  6FEE      	MOVWF gbl_cdc_rx_end, 1

			} // else... just ignore it, we've lost a byte, no room in the inn
		}
	}
}
06CE  0012      	RETURN
06DA  0012      	RETURN


void usb_ep_data_in_callback(uns8 end_point, uns16 byte_count) {

	// data has been sent, so do we need to send more?
	usb_cdc_handle_tx();
06C2  ECEDF001  	CALL usb_cdc_ha_00089

}
06C6  EFC7F004  	GOTO	label100



void usb_ep_get_rx_buffer(char length, char *buffer)
{
	uns8 count;

	if (length > 64)
		length = 64;		// check for buffer overflow length

	for (count = 0; count < length; count++)
	{
		buffer[count] = cdc_rx_buffer[count];
	}
	cdc_rx_end = cdc_rx_start;
}


void usb_cdc_putc(uns8 c) {

uns8 cdc_tx_next;
bit  my_store_gie;
#ifdef CDC_IDE_DEBUG
return;
#endif

	cdc_tx_next = cdc_tx_end + 1;	// get next buffer position
0DA0  29EC      	INCF gbl_cdc_tx_end, W, 1
0DA2  6FFD      	MOVWF usb_cdc_pu_00091_1_cdc_tx_next, 1

	if (cdc_tx_next == CDC_TX_BUFFER_SIZE) {	// if we're at the end
0DA4  0E40      	MOVLW 0x40
0DA6  63FD      	CPFSEQ usb_cdc_pu_00091_1_cdc_tx_next, 1
0DA8  D001      	BRA	label116
0DAC            label116

		cdc_tx_next = 0;	// wrap to the beginning
0DAA  6BFD      	CLRF usb_cdc_pu_00091_1_cdc_tx_next, 1

	}

	if ((!intcon.GIE) && (cdc_tx_next == cdc_tx_start)) {
0DAC  BEF2      	BTFSC gbl_intcon,7
0DAE  D004      	BRA	label117
0DB0  51EB      	MOVF gbl_cdc_tx_start, W, 1
0DB2  63FD      	CPFSEQ usb_cdc_pu_00091_1_cdc_tx_next, 1
0DB4  D001      	BRA	label117
0DB8            label117

		return;
	}
	while (cdc_tx_next == cdc_tx_start) {
0DB8  51EB      	MOVF gbl_cdc_tx_start, W, 1
0DBA  63FD      	CPFSEQ usb_cdc_pu_00091_1_cdc_tx_next, 1
0DBC  D001      	BRA	label118
0DBE  D7FC      	BRA	label117
0DC0            label118

	}
	my_store_gie = intcon.GIE;	// store interrupt state
0DC0  91FE      	BCF usb_cdc_pu_00091_1_my_store_gie,0, 1
0DC2  BEF2      	BTFSC gbl_intcon,7
0DC4  81FE      	BSF usb_cdc_pu_00091_1_my_store_gie,0, 1
0DC6            label119

	kill_interrupts();	// turn off global interrupts
0DC6  9EF2      	BCF gbl_intcon,7
0DC8  BEF2      	BTFSC gbl_intcon,7
0DCA  D7FD      	BRA	label119


	cdc_tx_buffer[cdc_tx_end] = c; // put it in
0DCC  0100      	MOVLB 0x00
0DCE  EE00F060  	LFSR 0x00, gbl_cdc_tx_buffer
0DD2  50E9      	MOVF FSR0L, W
0DD4  0101      	MOVLB 0x01
0DD6  51EC      	MOVF gbl_cdc_tx_end, W, 1
0DD8  26E9      	ADDWF FSR0L, F
0DDA  51FC      	MOVF usb_cdc_pu_00091_arg_c, W, 1
0DDC  6EEF      	MOVWF INDF0

	cdc_tx_end = cdc_tx_next;  // move pointer along
0DDE  51FD      	MOVF usb_cdc_pu_00091_1_cdc_tx_next, W, 1
0DE0  6FEC      	MOVWF gbl_cdc_tx_end, 1


	intcon.GIE = my_store_gie;	// restore interrupt state
0DE2  B1FE      	BTFSC usb_cdc_pu_00091_1_my_store_gie,0, 1
0DE4  8EF2      	BSF gbl_intcon,7
0DE6  A1FE      	BTFSS usb_cdc_pu_00091_1_my_store_gie,0, 1
0DE8  9EF2      	BCF gbl_intcon,7


}
0DB6  0012      	RETURN
0DEA  0012      	RETURN



void usb_cdc_handle_tx()

{
uns8 cdc_tx_next;
uns8 count;
uns16 buffer_size;
uns8 *buffer;
buffer_descriptor *bd;

#if 1  // defined(MX_USB_TYPE5) || defined (MX_USB_TYPE6)
	#if   (CDC_DATA_ENDPOINT == 1)
		bd = &bd1in;
	#elif (CDC_DATA_ENDPOINT == 2)
		bd = &bd2in;
	#elif (CDC_DATA_ENDPOINT == 3)
		bd = &bd3in;
03DA  0E02      	MOVLW HIGH(gbl_bd3in+D'0')
03DC  0102      	MOVLB 0x02
03DE  6F2D      	MOVWF usb_cdc_ha_00089_1_bd+D'1', 1
03E0  0E1C      	MOVLW LOW(gbl_bd3in+D'0')
03E2  6F2C      	MOVWF usb_cdc_ha_00089_1_bd, 1

	#else
		bd = &bd0in;
	#endif
#else
	bd = ep_in_bd_location[CDC_DATA_ENDPOINT];
#endif

	if (test_bit(bd->stat, UOWN)) {	// if there's already something in play
03E4  512D      	MOVF usb_cdc_ha_00089_1_bd+D'1', W, 1
03E6  6EEA      	MOVWF FSR0H
03E8  512C      	MOVF usb_cdc_ha_00089_1_bd, W, 1
03EA  6EE9      	MOVWF FSR0L
03EC  BEEF      	BTFSC INDF0,7

		return;	// give up
	}

	buffer_size = ep_in_buffer_size[CDC_DATA_ENDPOINT];
03F0  0101      	MOVLB 0x01
03F2  517D      	MOVF gbl_ep_in_buffer_size+D'6', W, 1
03F4  0102      	MOVLB 0x02
03F6  6F28      	MOVWF usb_cdc_ha_00089_1_buffer_size, 1
03F8  0101      	MOVLB 0x01
03FA  517E      	MOVF gbl_ep_in_buffer_size+D'7', W, 1
03FC  0102      	MOVLB 0x02
03FE  6F29      	MOVWF usb_cdc_ha_00089_1_buffer_size+D'1', 1

	buffer = ep_in_buffer_location[CDC_DATA_ENDPOINT];
0400  0101      	MOVLB 0x01
0402  516D      	MOVF gbl_ep_in_buffer_location+D'6', W, 1
0404  0102      	MOVLB 0x02
0406  6F2A      	MOVWF usb_cdc_ha_00089_1_buffer, 1
0408  0101      	MOVLB 0x01
040A  516E      	MOVF gbl_ep_in_buffer_location+D'7', W, 1
040C  0102      	MOVLB 0x02
040E  6F2B      	MOVWF usb_cdc_ha_00089_1_buffer+D'1', 1


	if (cdc_tx_end == cdc_tx_start) { // anything in the fifo?
0410  0101      	MOVLB 0x01
0412  51EB      	MOVF gbl_cdc_tx_start, W, 1
0414  63EC      	CPFSEQ gbl_cdc_tx_end, 1
0416  D001      	BRA	label35
041A            label35

	   return; // nope
	}

	start_crit_sec();
041A  0102      	MOVLB 0x02
041C  912E      	BCF usb_cdc_ha_00089_1_store_gie,0, 1
041E  BEF2      	BTFSC gbl_intcon,7
0420  812E      	BSF usb_cdc_ha_00089_1_store_gie,0, 1
0422            label36
0422  9EF2      	BCF gbl_intcon,7
0424  BEF2      	BTFSC gbl_intcon,7
0426  D7FD      	BRA	label36


	count = 0;
0428  6B27      	CLRF usb_cdc_ha_00089_1_count, 1

	while ((cdc_tx_end != cdc_tx_start) && (count < buffer_size)) {
042A            label37
042A  0101      	MOVLB 0x01
042C  51EB      	MOVF gbl_cdc_tx_start, W, 1
042E  63EC      	CPFSEQ gbl_cdc_tx_end, 1
0430  63EB      	CPFSEQ gbl_cdc_tx_start, 1
0432  D025      	BRA	label39
0434  0102      	MOVLB 0x02
0436  5128      	MOVF usb_cdc_ha_00089_1_buffer_size, W, 1
0438  6127      	CPFSLT usb_cdc_ha_00089_1_count, 1
043A  5129      	MOVF usb_cdc_ha_00089_1_buffer_size+D'1', W, 1
043C  E020      	BZ	label39
047C  D7D6      	BRA	label37
047E            label39


		cdc_tx_next = cdc_tx_start + 1;	// get next position
043E  0101      	MOVLB 0x01
0440  29EB      	INCF gbl_cdc_tx_start, W, 1
0442  0102      	MOVLB 0x02
0444  6F26      	MOVWF usb_cdc_ha_00089_1_cdc_tx_next, 1

		if (cdc_tx_next == CDC_TX_BUFFER_SIZE) {	// if we're at the end of the buffer
0446  0E40      	MOVLW 0x40
0448  6326      	CPFSEQ usb_cdc_ha_00089_1_cdc_tx_next, 1
044A  D001      	BRA	label38
044E            label38

			cdc_tx_next = 0;	// wrap to the beginning
044C  6B26      	CLRF usb_cdc_ha_00089_1_cdc_tx_next, 1

		}
		buffer[count] = cdc_tx_buffer[cdc_tx_start];	// transmit the character
044E  0100      	MOVLB 0x00
0450  EE00F060  	LFSR 0x00, gbl_cdc_tx_buffer
0454  50E9      	MOVF FSR0L, W
0456  0101      	MOVLB 0x01
0458  51EB      	MOVF gbl_cdc_tx_start, W, 1
045A  0102      	MOVLB 0x02
045C  6F2F      	MOVWF CompTempVar2779, 1
045E  512F      	MOVF CompTempVar2779, W, 1
0460  26E9      	ADDWF FSR0L, F
0462  50EF      	MOVF INDF0, W
0464  6F30      	MOVWF CompTempVar2780, 1
0466  512B      	MOVF usb_cdc_ha_00089_1_buffer+D'1', W, 1
0468  6EEA      	MOVWF FSR0H
046A  512A      	MOVF usb_cdc_ha_00089_1_buffer, W, 1
046C  2527      	ADDWF usb_cdc_ha_00089_1_count, W, 1
046E  6EE9      	MOVWF FSR0L
0470  5130      	MOVF CompTempVar2780, W, 1
0472  6EEF      	MOVWF INDF0

		count++;
0474  2B27      	INCF usb_cdc_ha_00089_1_count, F, 1

		cdc_tx_start = cdc_tx_next;	// move start position of fifo
0476  5126      	MOVF usb_cdc_ha_00089_1_cdc_tx_next, W, 1
0478  0101      	MOVLB 0x01
047A  6FEB      	MOVWF gbl_cdc_tx_start, 1

	}
	if (count > 0) {
047E  0E00      	MOVLW 0x00
0480  0102      	MOVLB 0x02
0482  6527      	CPFSGT usb_cdc_ha_00089_1_count, 1
0484  D02B      	BRA	label42
04DC            label42

		bd->count = count;
0486  512D      	MOVF usb_cdc_ha_00089_1_bd+D'1', W, 1
0488  6EEA      	MOVWF FSR0H
048A  292C      	INCF usb_cdc_ha_00089_1_bd, W, 1
048C  6EE9      	MOVWF FSR0L
048E  5127      	MOVF usb_cdc_ha_00089_1_count, W, 1
0490  6EEF      	MOVWF INDF0

		bd->addr = (uns16)buffer;
0492  06E9      	DECF FSR0L, F
0494  0E02      	MOVLW 0x02
0496  26E9      	ADDWF FSR0L, F
0498  2AE9      	INCF FSR0L, F
049A  512A      	MOVF usb_cdc_ha_00089_1_buffer, W, 1
049C  6F2F      	MOVWF CompTempVar2781, 1
049E  512B      	MOVF usb_cdc_ha_00089_1_buffer+D'1', W, 1
04A0  6EEF      	MOVWF INDF0
04A2  06E9      	DECF FSR0L, F
04A4  512F      	MOVF CompTempVar2781, W, 1
04A6  6EEF      	MOVWF INDF0

		if(test_bit(bd->stat, DTS))
04A8  512C      	MOVF usb_cdc_ha_00089_1_bd, W, 1
04AA  6EE9      	MOVWF FSR0L
04AC  ACEF      	BTFSS INDF0,6
04AE  D006      	BRA	label40
04BC            label40

			clear_bit(bd->stat, DTS);
04B0  512D      	MOVF usb_cdc_ha_00089_1_bd+D'1', W, 1
04B2  6EEA      	MOVWF FSR0H
04B4  512C      	MOVF usb_cdc_ha_00089_1_bd, W, 1
04B6  6EE9      	MOVWF FSR0L
04B8  9CEF      	BCF INDF0,6

		else set_bit(bd->stat, DTS);
04BA  D005      	BRA	label41
04BC  512D      	MOVF usb_cdc_ha_00089_1_bd+D'1', W, 1
04BE  6EEA      	MOVWF FSR0H
04C0  512C      	MOVF usb_cdc_ha_00089_1_bd, W, 1
04C2  6EE9      	MOVWF FSR0L
04C4  8CEF      	BSF INDF0,6
04C6            label41

		clear_bit(bd->stat, KEN);	// clear the keep bit
04C6  512D      	MOVF usb_cdc_ha_00089_1_bd+D'1', W, 1
04C8  6EEA      	MOVWF FSR0H
04CA  512C      	MOVF usb_cdc_ha_00089_1_bd, W, 1
04CC  6EE9      	MOVWF FSR0L
04CE  9AEF      	BCF INDF0,5

		clear_bit(bd->stat, INCDIS);	// clear the increment disable
04D0  98EF      	BCF INDF0,4

		set_bit  (bd->stat, DTSEN);
04D2  86EF      	BSF INDF0,3

		clear_bit(bd->stat, BSTALL);	// clear stall bit
04D4  94EF      	BCF INDF0,2

		clear_bit(bd->stat, BC9);
04D6  92EF      	BCF INDF0,1

		clear_bit(bd->stat, BC8);
04D8  90EF      	BCF INDF0,0


		set_bit  (bd->stat, UOWN);	// SIE owns the buffer
04DA  8EEF      	BSF INDF0,7

	}
	end_crit_sec();
04DC  B12E      	BTFSC usb_cdc_ha_00089_1_store_gie,0, 1
04DE  8EF2      	BSF gbl_intcon,7
04E0  A12E      	BTFSS usb_cdc_ha_00089_1_store_gie,0, 1
04E2  9EF2      	BCF gbl_intcon,7

}
03EE  0012      	RETURN
0418  0012      	RETURN
04E4  0012      	RETURN


uns8 usb_cdc_rx_avail() { return (cdc_rx_end - cdc_rx_start); }
uns8 usb_cdc_tx_empty() { return cdc_tx_start == cdc_tx_end; }
0D36  0101      	MOVLB 0x01
0D38  6BFB      	CLRF CompTempVarRet2789, 1
0D3A  51EC      	MOVF gbl_cdc_tx_end, W, 1
0D3C  63EB      	CPFSEQ gbl_cdc_tx_start, 1
0D3E  0012      	RETURN
0D40  2BFB      	INCF CompTempVarRet2789, F, 1
0D42  0012      	RETURN


void usb_cdc_print_str(char *str) {

uns8 count;
buffer_descriptor *bd;

	for(count = 0 ; str[count] != 0; count++)
    {
        usb_cdc_putc(str[count]);
    }
}

void usb_SOF_callback(uns16 frame) {

	// we don't care about the frame number, we only care if there's something to send...
	usb_cdc_handle_tx();	// start transmission
0A7E  ECEDF001  	CALL usb_cdc_ha_00089

}
0A82  EF63F005  	GOTO	label114


void usb_cdc_setup() {

	line_coding *my_lc;
	my_lc = (line_coding*) &class_data;
0D44  0E01      	MOVLW HIGH(gbl_class_data+D'0')
0D46  0101      	MOVLB 0x01
0D48  6FF6      	MOVWF usb_cdc_se_00095_1_my_lc+D'1', 1
0D4A  0E87      	MOVLW LOW(gbl_class_data+D'0')
0D4C  6FF5      	MOVWF usb_cdc_se_00095_1_my_lc, 1

	my_lc->dte_rate.as_long = 0x60090000;
0D4E  51F6      	MOVF usb_cdc_se_00095_1_my_lc+D'1', W, 1
0D50  6EEA      	MOVWF FSR0H
0D52  51F5      	MOVF usb_cdc_se_00095_1_my_lc, W, 1
0D54  6EE9      	MOVWF FSR0L
0D56  0E03      	MOVLW 0x03
0D58  26E9      	ADDWF FSR0L, F
0D5A  0E00      	MOVLW 0x00
0D5C  6FF7      	MOVWF CompTempVar2797, 1
0D5E  6FF8      	MOVWF CompTempVar2797+D'1', 1
0D60  0E09      	MOVLW 0x09
0D62  6FF9      	MOVWF CompTempVar2797+D'2', 1
0D64  0E60      	MOVLW 0x60
0D66  6EEF      	MOVWF INDF0
0D68  06E9      	DECF FSR0L, F
0D6A  51F9      	MOVF CompTempVar2797+D'2', W, 1
0D6C  6EEF      	MOVWF INDF0
0D6E  06E9      	DECF FSR0L, F
0D70  51F8      	MOVF CompTempVar2797+D'1', W, 1
0D72  6EEF      	MOVWF INDF0
0D74  06E9      	DECF FSR0L, F
0D76  51F7      	MOVF CompTempVar2797, W, 1
0D78  6EEF      	MOVWF INDF0

	my_lc->stop_bits = 0;
0D7A  51F5      	MOVF usb_cdc_se_00095_1_my_lc, W, 1
0D7C  6EE9      	MOVWF FSR0L
0D7E  0E04      	MOVLW 0x04
0D80  26E9      	ADDWF FSR0L, F
0D82  0E00      	MOVLW 0x00
0D84  6EEF      	MOVWF INDF0

	my_lc->data_bits = 8;
0D86  51F5      	MOVF usb_cdc_se_00095_1_my_lc, W, 1
0D88  6EE9      	MOVWF FSR0L
0D8A  0E06      	MOVLW 0x06
0D8C  26E9      	ADDWF FSR0L, F
0D8E  0E08      	MOVLW 0x08
0D90  6EEF      	MOVWF INDF0

	my_lc->parity = 0;
0D92  51F5      	MOVF usb_cdc_se_00095_1_my_lc, W, 1
0D94  6EE9      	MOVWF FSR0L
0D96  0E05      	MOVLW 0x05
0D98  26E9      	ADDWF FSR0L, F
0D9A  0E00      	MOVLW 0x00
0D9C  6EEF      	MOVWF INDF0

}
0D9E  0012      	RETURN


/*********************************************************************
 *                    Flowcode USB Component Code
 *
 * File: usb_config_serial.c
 *
 * (c) 2009 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 031008 | BR | Created
 * 190711 | BR | Confirmed current version
 ********************************************************************/

#include "pic_usb.h"

typedef struct _configuration {
	configuration_descriptor cdc_config;
	interface_descriptor cdc_comm_interface;
	CDC_header_functional_descriptor cdc_header;
	CDC_ACM_functional_descriptor cdc_ACM;
	CDC_union_functional_descriptor cdc_union;
	CDC_call_mgt_functional_descriptor cdc_call_mgt;
	endpoint_descriptor cdc_notification_ep;
	interface_descriptor cdc_data_interface;
	endpoint_descriptor cdc_data_out_ep;
	endpoint_descriptor cdc_data_in_ep;
} configuration;


// Structure Defines
device_descriptor my_device_descriptor;
configuration_descriptor my_config;
interface_descriptor my_comm_interface;
CDC_header_functional_descriptor my_header;
CDC_ACM_functional_descriptor my_ACM;
CDC_union_functional_descriptor my_union;
CDC_call_mgt_functional_descriptor my_call_mgt;
endpoint_descriptor my_notification_ep;
interface_descriptor my_data_interface;
endpoint_descriptor my_data_out_ep;
endpoint_descriptor my_data_in_ep;
configuration complete_serial_configuration;



uns8 string_00 [] =
	{
		4,	// length,
127E  0E04      	MOVLW 0x04
1280  6FC2      	MOVWF gbl_string_00, 1

		dt_STRING,	// descriptor type
1282  0E03      	MOVLW 0x03
1284  6FC3      	MOVWF gbl_string_00+D'1', 1

		9,	// magic for US english
1286  0E09      	MOVLW 0x09
1288  6FC4      	MOVWF gbl_string_00+D'2', 1

		4
128A  0E04      	MOVLW 0x04
128C  6FC5      	MOVWF gbl_string_00+D'3', 1

	};


void usb_configure_structures(void)

{
	// device descriptor - - - - - - - - - -
	my_device_descriptor.length = sizeof(device_descriptor); 		// bytes long
0AFC  0E12      	MOVLW 0x12
0AFE  6E48      	MOVWF gbl_my_device_descriptor

	my_device_descriptor.descriptor_type = dt_DEVICE; 				// DEVICE 01h
0B00  0E01      	MOVLW 0x01
0B02  6E49      	MOVWF gbl_my_device_descriptor+D'1'

	my_device_descriptor.usb_version = 0x0110;						// usb version 1.10
0B04  0E10      	MOVLW 0x10
0B06  6E4A      	MOVWF gbl_my_device_descriptor+D'2'
0B08  0E01      	MOVLW 0x01
0B0A  6E4B      	MOVWF gbl_my_device_descriptor+D'3'

	my_device_descriptor.device_class = 2;							// class (communication device class)
0B0C  0E02      	MOVLW 0x02
0B0E  6E4C      	MOVWF gbl_my_device_descriptor+D'4'

	my_device_descriptor.device_subclass = 0;						// subclass (unused)
0B10  6A4D      	CLRF gbl_my_device_descriptor+D'5'

	my_device_descriptor.device_protocol = 0;						// protocol	(unused)
0B12  6A4E      	CLRF gbl_my_device_descriptor+D'6'

	my_device_descriptor.max_packet_size_ep0 = USB_EP0_OUT_SIZE;	// max packet size for end point 0
0B14  0E08      	MOVLW 0x08
0B16  6E4F      	MOVWF gbl_my_device_descriptor+D'7'

	my_device_descriptor.vendor_id = MX_VID;						// Matrix's vendor
0B18  0EBF      	MOVLW 0xBF
0B1A  6E50      	MOVWF gbl_my_device_descriptor+D'8'
0B1C  0E12      	MOVLW 0x12
0B1E  6E51      	MOVWF gbl_my_device_descriptor+D'9'

	my_device_descriptor.product_id = MX_PID;						// Matrix's product
0B20  0E10      	MOVLW 0x10
0B22  6E52      	MOVWF gbl_my_device_descriptor+D'10'
0B24  0EF0      	MOVLW 0xF0
0B26  6E53      	MOVWF gbl_my_device_descriptor+D'11'

	my_device_descriptor.device_release = MX_VERSION;				// version 2.0 of the product
0B28  6A54      	CLRF gbl_my_device_descriptor+D'12'
0B2A  0E01      	MOVLW 0x01
0B2C  6E55      	MOVWF gbl_my_device_descriptor+D'13'

	my_device_descriptor.manufacturer_string_id = 1;				// string 1 for manufacturer
0B2E  6E56      	MOVWF gbl_my_device_descriptor+D'14'

	my_device_descriptor.product_string_id = 2;						// string 2 for product
0B30  0E02      	MOVLW 0x02
0B32  6E57      	MOVWF gbl_my_device_descriptor+D'15'

	my_device_descriptor.serial_string_id = 0;						// string 3 for serial number
0B34  6A58      	CLRF gbl_my_device_descriptor+D'16'

	my_device_descriptor.num_configurations = 1;					// number of configurations
0B36  0E01      	MOVLW 0x01
0B38  6E59      	MOVWF gbl_my_device_descriptor+D'17'


	// configuration descriptor - - - - - - - - - -
	my_config.length = sizeof(configuration_descriptor);			// length,
0B3A  0E09      	MOVLW 0x09
0B3C  0100      	MOVLB 0x00
0B3E  6FEA      	MOVWF gbl_my_config, 1

	my_config.descriptor_type = dt_CONFIGURATION;					// descriptor_type,
0B40  0E02      	MOVLW 0x02
0B42  6FEB      	MOVWF gbl_my_config+D'1', 1

	my_config.total_length = sizeof(complete_serial_configuration);	// total_length;
0B44  0E43      	MOVLW 0x43
0B46  6FEC      	MOVWF gbl_my_config+D'2', 1
0B48  6BED      	CLRF gbl_my_config+D'3', 1

	my_config.num_interfaces = 0x02;								// num_interfaces,
0B4A  0E02      	MOVLW 0x02
0B4C  6FEE      	MOVWF gbl_my_config+D'4', 1

	my_config.configuration_value = 0x01;							// configuration_value,
0B4E  0E01      	MOVLW 0x01
0B50  6FEF      	MOVWF gbl_my_config+D'5', 1

	my_config.configuration_string_id = 0x00;						// configuration_string_id,
0B52  6BF0      	CLRF gbl_my_config+D'6', 1

	my_config.attributes = 0b10000000; 								// attributes (bus powered, no remote wake up)
0B54  0E80      	MOVLW 0x80
0B56  6FF1      	MOVWF gbl_my_config+D'7', 1

	my_config.max_power = 100;										// max_power; (200ma)
0B58  0E64      	MOVLW 0x64
0B5A  6FF2      	MOVWF gbl_my_config+D'8', 1


	// Communication interface descriptor - - - - - - - - - - - -
	my_comm_interface.length = sizeof(interface_descriptor);		// length,
0B5C  0E09      	MOVLW 0x09
0B5E  6FF3      	MOVWF gbl_my_comm_interface, 1

	my_comm_interface.descriptor_type = dt_INTERFACE;				// descriptor_type,
0B60  0E04      	MOVLW 0x04
0B62  6FF4      	MOVWF gbl_my_comm_interface+D'1', 1

	my_comm_interface.interface_number = 0x00;						// interface_number, (starts at zero)
0B64  6BF5      	CLRF gbl_my_comm_interface+D'2', 1

	my_comm_interface.alternate_setting = 0x00;						// alternate_setting, (no alternatives)
0B66  6BF6      	CLRF gbl_my_comm_interface+D'3', 1

	my_comm_interface.num_endpoints = 0x01;							// num_endpoints,
0B68  0E01      	MOVLW 0x01
0B6A  6FF7      	MOVWF gbl_my_comm_interface+D'4', 1

	my_comm_interface.interface_class = 0x02;						// interface_class, (Communication Interface Class)
0B6C  0E02      	MOVLW 0x02
0B6E  6FF8      	MOVWF gbl_my_comm_interface+D'5', 1

	my_comm_interface.interface_subclass = 0x02;					// interface_subclass, (Abstract Control Model subclass)
0B70  6FF9      	MOVWF gbl_my_comm_interface+D'6', 1

	my_comm_interface.interface_protocol = 0x01;					// interface_protocol, (AT commands)
0B72  0E01      	MOVLW 0x01
0B74  6FFA      	MOVWF gbl_my_comm_interface+D'7', 1

	my_comm_interface.interface_string_id = 0x00;					// interface_string_id;
0B76  6BFB      	CLRF gbl_my_comm_interface+D'8', 1


	// CDC header functional descriptor - - - - - - - - - - - - - -
	my_header.length = sizeof(CDC_header_functional_descriptor);	// length,
0B78  0E05      	MOVLW 0x05
0B7A  6E5A      	MOVWF gbl_my_header

	my_header.descriptor_type = dt_CS_INTERFACE;					// descriptor_type (CS_INTERFACE = 0x24)
0B7C  0E24      	MOVLW 0x24
0B7E  6E5B      	MOVWF gbl_my_header+D'1'

	my_header.descriptor_subtype = 0x00;							// descriptor_subtype (Header functional descriptor = 0x00)
0B80  6A5C      	CLRF gbl_my_header+D'2'

	my_header.CDC_version = 0x0110;									// CDC_version (BCD release of CDC spec = 0x0110)
0B82  0E10      	MOVLW 0x10
0B84  6E5D      	MOVWF gbl_my_header+D'3'
0B86  0E01      	MOVLW 0x01
0B88  6E5E      	MOVWF gbl_my_header+D'4'


	// Abstract Control Model functional descriptor - - - - - - - -
	my_ACM.length = sizeof(CDC_ACM_functional_descriptor);			// length,
0B8A  0E04      	MOVLW 0x04
0B8C  0101      	MOVLB 0x01
0B8E  6FBE      	MOVWF gbl_my_ACM, 1

	my_ACM.descriptor_type = dt_CS_INTERFACE;						// descriptor_type (CS_INTERFACE = 0x24)
0B90  0E24      	MOVLW 0x24
0B92  6FBF      	MOVWF gbl_my_ACM+D'1', 1

	my_ACM.descriptor_subtype = 0x02;								// descriptor_subtype (ACM functional descriptor subtype = 0x02)
0B94  0E02      	MOVLW 0x02
0B96  6FC0      	MOVWF gbl_my_ACM+D'2', 1

	my_ACM.capabilities = 0x02;										// capabilities (Device supports the request combination of Set_Line_Coding,
0B98  6FC1      	MOVWF gbl_my_ACM+D'3', 1

																	// Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State.
																	// See http://www.usb.org/developers/devclass_docs/usbcdc11.pdf p36

	// Union functional descriptor - - - - - - - - - - - - - - -
	my_union.length = sizeof(CDC_union_functional_descriptor);		// length
0B9A  0E05      	MOVLW 0x05
0B9C  6FA4      	MOVWF gbl_my_union, 1

	my_union.descriptor_type = dt_CS_INTERFACE;						// descriptor_type (CS_INTERFACE = 0x24)
0B9E  0E24      	MOVLW 0x24
0BA0  6FA5      	MOVWF gbl_my_union+D'1', 1

	my_union.descriptor_subtype = 0x06;								// descriptor_subtype (Union functional descriptor subtype = 0x06)
0BA2  0E06      	MOVLW 0x06
0BA4  6FA6      	MOVWF gbl_my_union+D'2', 1

	my_union.master_interface = 0x00;								// master_interface (Controlling interface number = 0x00)
0BA6  6BA7      	CLRF gbl_my_union+D'3', 1

	my_union.slave_interface = 0x01;								// slave_interface (First slave interface = 0x01)
0BA8  0E01      	MOVLW 0x01
0BAA  6FA8      	MOVWF gbl_my_union+D'4', 1


	// Call management functional descriptor - - - - - - - - - -
	my_call_mgt.length = sizeof(CDC_call_mgt_functional_descriptor);
0BAC  0E05      	MOVLW 0x05
0BAE  6FA9      	MOVWF gbl_my_call_mgt, 1

	my_call_mgt.descriptor_type = dt_CS_INTERFACE;					// descriptor_type (CS_INTERFACE = 0x24)
0BB0  0E24      	MOVLW 0x24
0BB2  6FAA      	MOVWF gbl_my_call_mgt+D'1', 1

	my_call_mgt.descriptor_subtype = 0x01;							// descriptor_subtype (Call management functional descriptor subtype = 0x01)
0BB4  0E01      	MOVLW 0x01
0BB6  6FAB      	MOVWF gbl_my_call_mgt+D'2', 1

	my_call_mgt.capabilities = 0x00;								// capabilities
0BB8  6BAC      	CLRF gbl_my_call_mgt+D'3', 1

																	// bit 1 =0* Device sends/receives call management information only over
																	//           the Communication Class interface
																	//       =1  over data class interface
																	// bit 0 =0* Device does not handle call management itself
																	//       =1  Device handles call management itself
	my_call_mgt.data_interface = 0x01;								// Data_interface  (interface number of data class interface)
0BBA  0E01      	MOVLW 0x01
0BBC  6FAD      	MOVWF gbl_my_call_mgt+D'4', 1


	// Notification endpoint descriptor - - - - - - - - - - - - -
	my_notification_ep.length = sizeof(endpoint_descriptor);		// length,
0BBE  0E07      	MOVLW 0x07
0BC0  6F8F      	MOVWF gbl_my_notification_ep, 1

	my_notification_ep.descriptor_type = dt_ENDPOINT;				// descriptor_type,
0BC2  0E05      	MOVLW 0x05
0BC4  6F90      	MOVWF gbl_my_notification_ep+D'1', 1

	my_notification_ep.endpoint_address = 0b10000010;				// endpoint_address, (Endpoint 2, IN)
0BC6  0E82      	MOVLW 0x82
0BC8  6F91      	MOVWF gbl_my_notification_ep+D'2', 1

	my_notification_ep.attributes = 0b00000011;						// attributes; (Interrupt)
0BCA  0E03      	MOVLW 0x03
0BCC  6F92      	MOVWF gbl_my_notification_ep+D'3', 1

	my_notification_ep.max_packet_size = USB_EP2_IN_SIZE;			// max_packet_size;
0BCE  0E08      	MOVLW 0x08
0BD0  6F93      	MOVWF gbl_my_notification_ep+D'4', 1
0BD2  6B94      	CLRF gbl_my_notification_ep+D'5', 1

	my_notification_ep.interval = 2;								// interval (10ms)
0BD4  0E02      	MOVLW 0x02
0BD6  6F95      	MOVWF gbl_my_notification_ep+D'6', 1


	// Data interface descriptor - - - - - - - - - - - -
	my_data_interface.length = sizeof(interface_descriptor);		// length,
0BD8  0E09      	MOVLW 0x09
0BDA  6F56      	MOVWF gbl_my_data_interface, 1

	my_data_interface.descriptor_type = dt_INTERFACE;				// descriptor_type,
0BDC  0E04      	MOVLW 0x04
0BDE  6F57      	MOVWF gbl_my_data_interface+D'1', 1

	my_data_interface.interface_number = 0x01;						// interface_number, (starts at zero)
0BE0  0E01      	MOVLW 0x01
0BE2  6F58      	MOVWF gbl_my_data_interface+D'2', 1

	my_data_interface.alternate_setting = 0x00;						// alternate_setting, (no alternatives)
0BE4  6B59      	CLRF gbl_my_data_interface+D'3', 1

	my_data_interface.num_endpoints = 0x02;							// num_endpoints,
0BE6  0E02      	MOVLW 0x02
0BE8  6F5A      	MOVWF gbl_my_data_interface+D'4', 1

	my_data_interface.interface_class = 0x0A;						// interface_class, (Device Interface Class)
0BEA  0E0A      	MOVLW 0x0A
0BEC  6F5B      	MOVWF gbl_my_data_interface+D'5', 1

	my_data_interface.interface_subclass = 0x00;					// interface_subclass, (Data Interface subclass)
0BEE  6B5C      	CLRF gbl_my_data_interface+D'6', 1

	my_data_interface.interface_protocol = 0x00;					// interface_protocol
0BF0  6B5D      	CLRF gbl_my_data_interface+D'7', 1

	my_data_interface.interface_string_id = 0x00;					// interface_string_id;
0BF2  6B5E      	CLRF gbl_my_data_interface+D'8', 1


	// Data OUT endpoint descriptor - - - - - - - - - - - - -
	my_data_out_ep.length = sizeof(endpoint_descriptor);			// length,
0BF4  0E07      	MOVLW 0x07
0BF6  6F96      	MOVWF gbl_my_data_out_ep, 1

	my_data_out_ep.descriptor_type = dt_ENDPOINT;					// descriptor_type,
0BF8  0E05      	MOVLW 0x05
0BFA  6F97      	MOVWF gbl_my_data_out_ep+D'1', 1

	my_data_out_ep.endpoint_address = 0b00000011;					// endpoint_address, (Endpoint 3, OUT)
0BFC  0E03      	MOVLW 0x03
0BFE  6F98      	MOVWF gbl_my_data_out_ep+D'2', 1

	my_data_out_ep.attributes = 0b00000010;							// attributes; (Bulk)
0C00  0E02      	MOVLW 0x02
0C02  6F99      	MOVWF gbl_my_data_out_ep+D'3', 1

	my_data_out_ep.max_packet_size = USB_EP3_OUT_SIZE;				// max_packet_size;
0C04  0E08      	MOVLW 0x08
0C06  6F9A      	MOVWF gbl_my_data_out_ep+D'4', 1
0C08  6B9B      	CLRF gbl_my_data_out_ep+D'5', 1

	my_data_out_ep.interval = 0;									// no interval
0C0A  6B9C      	CLRF gbl_my_data_out_ep+D'6', 1


	// Data IN endpoint descriptor - - - - - - - - - - - - -
	my_data_in_ep.length = sizeof(endpoint_descriptor);				// length,
0C0C  0E07      	MOVLW 0x07
0C0E  6F9D      	MOVWF gbl_my_data_in_ep, 1

	my_data_in_ep.descriptor_type = dt_ENDPOINT;					// descriptor_type,
0C10  0E05      	MOVLW 0x05
0C12  6F9E      	MOVWF gbl_my_data_in_ep+D'1', 1

	my_data_in_ep.endpoint_address = 0b10000011;					// endpoint_address, (Endpoint 3, IN)
0C14  0E83      	MOVLW 0x83
0C16  6F9F      	MOVWF gbl_my_data_in_ep+D'2', 1

	my_data_in_ep.attributes = 0b00000010;							// attributes; (Bulk)
0C18  0E02      	MOVLW 0x02
0C1A  6FA0      	MOVWF gbl_my_data_in_ep+D'3', 1

	my_data_in_ep.max_packet_size = USB_EP3_IN_SIZE;				// max_packet_size;
0C1C  0E08      	MOVLW 0x08
0C1E  6FA1      	MOVWF gbl_my_data_in_ep+D'4', 1
0C20  6BA2      	CLRF gbl_my_data_in_ep+D'5', 1

	my_data_in_ep.interval = 0;										// no interval
0C22  6BA3      	CLRF gbl_my_data_in_ep+D'6', 1


	// Collect into one enumeration structure - - - - - - - - - - - - -
	complete_serial_configuration.cdc_config = my_config;
0C24  0100      	MOVLB 0x00
0C26  51F2      	MOVF gbl_my_config+D'8', W, 1
0C28  6E0D      	MOVWF gbl_complete_serial_config_00000+D'8'
0C2A  51F1      	MOVF gbl_my_config+D'7', W, 1
0C2C  6E0C      	MOVWF gbl_complete_serial_config_00000+D'7'
0C2E  51F0      	MOVF gbl_my_config+D'6', W, 1
0C30  6E0B      	MOVWF gbl_complete_serial_config_00000+D'6'
0C32  51EF      	MOVF gbl_my_config+D'5', W, 1
0C34  6E0A      	MOVWF gbl_complete_serial_config_00000+D'5'
0C36  51EE      	MOVF gbl_my_config+D'4', W, 1
0C38  6E09      	MOVWF gbl_complete_serial_config_00000+D'4'
0C3A  51ED      	MOVF gbl_my_config+D'3', W, 1
0C3C  6E08      	MOVWF gbl_complete_serial_config_00000+D'3'
0C3E  51EC      	MOVF gbl_my_config+D'2', W, 1
0C40  6E07      	MOVWF gbl_complete_serial_config_00000+D'2'
0C42  51EB      	MOVF gbl_my_config+D'1', W, 1
0C44  6E06      	MOVWF gbl_complete_serial_config_00000+D'1'
0C46  51EA      	MOVF gbl_my_config, W, 1
0C48  6E05      	MOVWF gbl_complete_serial_config_00000

	complete_serial_configuration.cdc_comm_interface = my_comm_interface;
0C4A  51FB      	MOVF gbl_my_comm_interface+D'8', W, 1
0C4C  6E16      	MOVWF gbl_complete_serial_config_00000+D'17'
0C4E  51FA      	MOVF gbl_my_comm_interface+D'7', W, 1
0C50  6E15      	MOVWF gbl_complete_serial_config_00000+D'16'
0C52  51F9      	MOVF gbl_my_comm_interface+D'6', W, 1
0C54  6E14      	MOVWF gbl_complete_serial_config_00000+D'15'
0C56  51F8      	MOVF gbl_my_comm_interface+D'5', W, 1
0C58  6E13      	MOVWF gbl_complete_serial_config_00000+D'14'
0C5A  51F7      	MOVF gbl_my_comm_interface+D'4', W, 1
0C5C  6E12      	MOVWF gbl_complete_serial_config_00000+D'13'
0C5E  51F6      	MOVF gbl_my_comm_interface+D'3', W, 1
0C60  6E11      	MOVWF gbl_complete_serial_config_00000+D'12'
0C62  51F5      	MOVF gbl_my_comm_interface+D'2', W, 1
0C64  6E10      	MOVWF gbl_complete_serial_config_00000+D'11'
0C66  51F4      	MOVF gbl_my_comm_interface+D'1', W, 1
0C68  6E0F      	MOVWF gbl_complete_serial_config_00000+D'10'
0C6A  51F3      	MOVF gbl_my_comm_interface, W, 1
0C6C  6E0E      	MOVWF gbl_complete_serial_config_00000+D'9'

	complete_serial_configuration.cdc_header = my_header;
0C6E  505E      	MOVF gbl_my_header+D'4', W
0C70  6E1B      	MOVWF gbl_complete_serial_config_00000+D'22'
0C72  505D      	MOVF gbl_my_header+D'3', W
0C74  6E1A      	MOVWF gbl_complete_serial_config_00000+D'21'
0C76  505C      	MOVF gbl_my_header+D'2', W
0C78  6E19      	MOVWF gbl_complete_serial_config_00000+D'20'
0C7A  505B      	MOVF gbl_my_header+D'1', W
0C7C  6E18      	MOVWF gbl_complete_serial_config_00000+D'19'
0C7E  505A      	MOVF gbl_my_header, W
0C80  6E17      	MOVWF gbl_complete_serial_config_00000+D'18'

	complete_serial_configuration.cdc_ACM = my_ACM;
0C82  0101      	MOVLB 0x01
0C84  51C1      	MOVF gbl_my_ACM+D'3', W, 1
0C86  6E1F      	MOVWF gbl_complete_serial_config_00000+D'26'
0C88  51C0      	MOVF gbl_my_ACM+D'2', W, 1
0C8A  6E1E      	MOVWF gbl_complete_serial_config_00000+D'25'
0C8C  51BF      	MOVF gbl_my_ACM+D'1', W, 1
0C8E  6E1D      	MOVWF gbl_complete_serial_config_00000+D'24'
0C90  51BE      	MOVF gbl_my_ACM, W, 1
0C92  6E1C      	MOVWF gbl_complete_serial_config_00000+D'23'

	complete_serial_configuration.cdc_union = my_union;
0C94  51A8      	MOVF gbl_my_union+D'4', W, 1
0C96  6E24      	MOVWF gbl_complete_serial_config_00000+D'31'
0C98  51A7      	MOVF gbl_my_union+D'3', W, 1
0C9A  6E23      	MOVWF gbl_complete_serial_config_00000+D'30'
0C9C  51A6      	MOVF gbl_my_union+D'2', W, 1
0C9E  6E22      	MOVWF gbl_complete_serial_config_00000+D'29'
0CA0  51A5      	MOVF gbl_my_union+D'1', W, 1
0CA2  6E21      	MOVWF gbl_complete_serial_config_00000+D'28'
0CA4  51A4      	MOVF gbl_my_union, W, 1
0CA6  6E20      	MOVWF gbl_complete_serial_config_00000+D'27'

	complete_serial_configuration.cdc_call_mgt = my_call_mgt;
0CA8  51AD      	MOVF gbl_my_call_mgt+D'4', W, 1
0CAA  6E29      	MOVWF gbl_complete_serial_config_00000+D'36'
0CAC  51AC      	MOVF gbl_my_call_mgt+D'3', W, 1
0CAE  6E28      	MOVWF gbl_complete_serial_config_00000+D'35'
0CB0  51AB      	MOVF gbl_my_call_mgt+D'2', W, 1
0CB2  6E27      	MOVWF gbl_complete_serial_config_00000+D'34'
0CB4  51AA      	MOVF gbl_my_call_mgt+D'1', W, 1
0CB6  6E26      	MOVWF gbl_complete_serial_config_00000+D'33'
0CB8  51A9      	MOVF gbl_my_call_mgt, W, 1
0CBA  6E25      	MOVWF gbl_complete_serial_config_00000+D'32'

	complete_serial_configuration.cdc_notification_ep = my_notification_ep;
0CBC  5195      	MOVF gbl_my_notification_ep+D'6', W, 1
0CBE  6E30      	MOVWF gbl_complete_serial_config_00000+D'43'
0CC0  5194      	MOVF gbl_my_notification_ep+D'5', W, 1
0CC2  6E2F      	MOVWF gbl_complete_serial_config_00000+D'42'
0CC4  5193      	MOVF gbl_my_notification_ep+D'4', W, 1
0CC6  6E2E      	MOVWF gbl_complete_serial_config_00000+D'41'
0CC8  5192      	MOVF gbl_my_notification_ep+D'3', W, 1
0CCA  6E2D      	MOVWF gbl_complete_serial_config_00000+D'40'
0CCC  5191      	MOVF gbl_my_notification_ep+D'2', W, 1
0CCE  6E2C      	MOVWF gbl_complete_serial_config_00000+D'39'
0CD0  5190      	MOVF gbl_my_notification_ep+D'1', W, 1
0CD2  6E2B      	MOVWF gbl_complete_serial_config_00000+D'38'
0CD4  518F      	MOVF gbl_my_notification_ep, W, 1
0CD6  6E2A      	MOVWF gbl_complete_serial_config_00000+D'37'

	complete_serial_configuration.cdc_data_interface = my_data_interface;
0CD8  515E      	MOVF gbl_my_data_interface+D'8', W, 1
0CDA  6E39      	MOVWF gbl_complete_serial_config_00000+D'52'
0CDC  515D      	MOVF gbl_my_data_interface+D'7', W, 1
0CDE  6E38      	MOVWF gbl_complete_serial_config_00000+D'51'
0CE0  515C      	MOVF gbl_my_data_interface+D'6', W, 1
0CE2  6E37      	MOVWF gbl_complete_serial_config_00000+D'50'
0CE4  515B      	MOVF gbl_my_data_interface+D'5', W, 1
0CE6  6E36      	MOVWF gbl_complete_serial_config_00000+D'49'
0CE8  515A      	MOVF gbl_my_data_interface+D'4', W, 1
0CEA  6E35      	MOVWF gbl_complete_serial_config_00000+D'48'
0CEC  5159      	MOVF gbl_my_data_interface+D'3', W, 1
0CEE  6E34      	MOVWF gbl_complete_serial_config_00000+D'47'
0CF0  5158      	MOVF gbl_my_data_interface+D'2', W, 1
0CF2  6E33      	MOVWF gbl_complete_serial_config_00000+D'46'
0CF4  5157      	MOVF gbl_my_data_interface+D'1', W, 1
0CF6  6E32      	MOVWF gbl_complete_serial_config_00000+D'45'
0CF8  5156      	MOVF gbl_my_data_interface, W, 1
0CFA  6E31      	MOVWF gbl_complete_serial_config_00000+D'44'

	complete_serial_configuration.cdc_data_out_ep = my_data_out_ep;
0CFC  519C      	MOVF gbl_my_data_out_ep+D'6', W, 1
0CFE  6E40      	MOVWF gbl_complete_serial_config_00000+D'59'
0D00  519B      	MOVF gbl_my_data_out_ep+D'5', W, 1
0D02  6E3F      	MOVWF gbl_complete_serial_config_00000+D'58'
0D04  519A      	MOVF gbl_my_data_out_ep+D'4', W, 1
0D06  6E3E      	MOVWF gbl_complete_serial_config_00000+D'57'
0D08  5199      	MOVF gbl_my_data_out_ep+D'3', W, 1
0D0A  6E3D      	MOVWF gbl_complete_serial_config_00000+D'56'
0D0C  5198      	MOVF gbl_my_data_out_ep+D'2', W, 1
0D0E  6E3C      	MOVWF gbl_complete_serial_config_00000+D'55'
0D10  5197      	MOVF gbl_my_data_out_ep+D'1', W, 1
0D12  6E3B      	MOVWF gbl_complete_serial_config_00000+D'54'
0D14  5196      	MOVF gbl_my_data_out_ep, W, 1
0D16  6E3A      	MOVWF gbl_complete_serial_config_00000+D'53'

	complete_serial_configuration.cdc_data_in_ep = my_data_in_ep;
0D18  51A3      	MOVF gbl_my_data_in_ep+D'6', W, 1
0D1A  6E47      	MOVWF gbl_complete_serial_config_00000+D'66'
0D1C  51A2      	MOVF gbl_my_data_in_ep+D'5', W, 1
0D1E  6E46      	MOVWF gbl_complete_serial_config_00000+D'65'
0D20  51A1      	MOVF gbl_my_data_in_ep+D'4', W, 1
0D22  6E45      	MOVWF gbl_complete_serial_config_00000+D'64'
0D24  51A0      	MOVF gbl_my_data_in_ep+D'3', W, 1
0D26  6E44      	MOVWF gbl_complete_serial_config_00000+D'63'
0D28  519F      	MOVF gbl_my_data_in_ep+D'2', W, 1
0D2A  6E43      	MOVWF gbl_complete_serial_config_00000+D'62'
0D2C  519E      	MOVF gbl_my_data_in_ep+D'1', W, 1
0D2E  6E42      	MOVWF gbl_complete_serial_config_00000+D'61'
0D30  519D      	MOVF gbl_my_data_in_ep, W, 1
0D32  6E41      	MOVWF gbl_complete_serial_config_00000+D'60'

}
0D34  0012      	RETURN




void usb_get_descriptor_callback(uns8 descriptor_type, uns8 descriptor_num,

                                 uns8 **rtn_descriptor_ptr, uns16 *rtn_descriptor_size) {

	uns8 *descriptor_ptr;
	uns16 descriptor_size;

	descriptor_ptr = (uns8 *) 0;	// this means we didn't find it
02B8  6B35      	CLRF usb_get_de_00080_1_descrip_00085, 1
02BA  6B36      	CLRF usb_get_de_00080_1_descrip_00085+D'1', 1

	switch (descriptor_type) {
		case dt_DEVICE:
02BC  052F      	DECF usb_get_de_00080_arg_descr_00081, W, 1
02BE  E00C      	BZ	label28
02D8            label28

			descriptor_ptr = (uns8 *)&my_device_descriptor;
02D8  0E00      	MOVLW HIGH(gbl_my_device_descriptor+D'0')
02DA  6F39      	MOVWF CompTempVar2763, 1
02DC  0E48      	MOVLW LOW(gbl_my_device_descriptor+D'0')
02DE  6F35      	MOVWF usb_get_de_00080_1_descrip_00085, 1
02E0  5139      	MOVF CompTempVar2763, W, 1
02E2  6F36      	MOVWF usb_get_de_00080_1_descrip_00085+D'1', 1

			descriptor_size = sizeof(my_device_descriptor);
02E4  0E12      	MOVLW 0x12
02E6  6F37      	MOVWF usb_get_de_00080_1_descrip_00086, 1
02E8  6B38      	CLRF usb_get_de_00080_1_descrip_00086+D'1', 1

			break;
02EA  D02F      	BRA	label34

		case dt_CONFIGURATION:
02C0  0E02      	MOVLW 0x02
02C2  632F      	CPFSEQ usb_get_de_00080_arg_descr_00081, 1
02C4  D001      	BRA	label26
02C6  D012      	BRA	label29
02C8            label26
02D6  D039      	BRA	label34
02EC            label29
030E  D014      	BRA	label33

			descriptor_ptr = (uns8 *) &complete_serial_configuration;
02EC  0E00      	MOVLW HIGH(gbl_complete_serial_config_00000+D'0')
02EE  6F39      	MOVWF CompTempVar2764, 1
02F0  0E05      	MOVLW LOW(gbl_complete_serial_config_00000+D'0')
02F2  6F35      	MOVWF usb_get_de_00080_1_descrip_00085, 1
02F4  5139      	MOVF CompTempVar2764, W, 1
02F6  6F36      	MOVWF usb_get_de_00080_1_descrip_00085+D'1', 1

			descriptor_size = sizeof(complete_serial_configuration);
02F8  0E43      	MOVLW 0x43
02FA  6F37      	MOVWF usb_get_de_00080_1_descrip_00086, 1
02FC  6B38      	CLRF usb_get_de_00080_1_descrip_00086+D'1', 1

			break;
02FE  D025      	BRA	label34

		case dt_STRING:
02C8  0E03      	MOVLW 0x03
02CA  632F      	CPFSEQ usb_get_de_00080_arg_descr_00081, 1
02CC  D001      	BRA	label27
02CE  D018      	BRA	label30
02D0            label27
0300            label30

			switch (descriptor_num) {
034A            label34

				case 00:
0300  5330      	MOVF usb_get_de_00080_arg_descr_00082, F, 1
0302  E006      	BZ	label31
0310            label31

					descriptor_size = sizeof(string_00);
0310  0E04      	MOVLW 0x04
0312  6F37      	MOVWF usb_get_de_00080_1_descrip_00086, 1
0314  6B38      	CLRF usb_get_de_00080_1_descrip_00086+D'1', 1

					descriptor_ptr = string_00;
0316  0E01      	MOVLW HIGH(gbl_string_00+D'0')
0318  6F39      	MOVWF CompTempVar2765, 1
031A  0EC2      	MOVLW LOW(gbl_string_00+D'0')
031C  6F35      	MOVWF usb_get_de_00080_1_descrip_00085, 1
031E  5139      	MOVF CompTempVar2765, W, 1
0320  6F36      	MOVWF usb_get_de_00080_1_descrip_00085+D'1', 1

					break;
0322  D013      	BRA	label34

				case 01:
0304  0530      	DECF usb_get_de_00080_arg_descr_00082, W, 1
0306  E00E      	BZ	label32
0324            label32

					descriptor_size = sizeof(MX_USBMFR);
0324  0E2E      	MOVLW 0x2E
0326  6F37      	MOVWF usb_get_de_00080_1_descrip_00086, 1
0328  6B38      	CLRF usb_get_de_00080_1_descrip_00086+D'1', 1

					descriptor_ptr = MX_USBMFR;
032A  0E01      	MOVLW HIGH(gbl_MX_USBMFR+D'0')
032C  6F39      	MOVWF CompTempVar2766, 1
032E  0E00      	MOVLW LOW(gbl_MX_USBMFR+D'0')
0330  6F35      	MOVWF usb_get_de_00080_1_descrip_00085, 1
0332  5139      	MOVF CompTempVar2766, W, 1
0334  6F36      	MOVWF usb_get_de_00080_1_descrip_00085+D'1', 1

					break;
0336  D009      	BRA	label34

				case 02:
0308  0E02      	MOVLW 0x02
030A  6330      	CPFSEQ usb_get_de_00080_arg_descr_00082, 1
030C  D01E      	BRA	label34
0338            label33

					descriptor_size = sizeof(MX_USBNAME);
0338  0E28      	MOVLW 0x28
033A  6F37      	MOVWF usb_get_de_00080_1_descrip_00086, 1
033C  6B38      	CLRF usb_get_de_00080_1_descrip_00086+D'1', 1

					descriptor_ptr = MX_USBNAME;
033E  0E01      	MOVLW HIGH(gbl_MX_USBNAME+D'0')
0340  6F39      	MOVWF CompTempVar2767, 1
0342  0E2E      	MOVLW LOW(gbl_MX_USBNAME+D'0')
0344  6F35      	MOVWF usb_get_de_00080_1_descrip_00085, 1
0346  5139      	MOVF CompTempVar2767, W, 1
0348  6F36      	MOVWF usb_get_de_00080_1_descrip_00085+D'1', 1

					break;

			}
			break;
		case dt_DEVICE_QUALIFIER:
02D0  0E06      	MOVLW 0x06
02D2  632F      	CPFSEQ usb_get_de_00080_arg_descr_00081, 1
02D4  D03A      	BRA	label34

			// we don't hfandle this, send a stall
			break;
		default:

	}
	*rtn_descriptor_ptr = descriptor_ptr;
034A  5132      	MOVF usb_get_de_00080_arg_rtn_d_00083+D'1', W, 1
034C  6EEA      	MOVWF FSR0H
034E  5131      	MOVF usb_get_de_00080_arg_rtn_d_00083, W, 1
0350  6EE9      	MOVWF FSR0L
0352  2AE9      	INCF FSR0L, F
0354  5135      	MOVF usb_get_de_00080_1_descrip_00085, W, 1
0356  6F39      	MOVWF CompTempVar2768, 1
0358  5136      	MOVF usb_get_de_00080_1_descrip_00085+D'1', W, 1
035A  6EEF      	MOVWF INDF0
035C  06E9      	DECF FSR0L, F
035E  5139      	MOVF CompTempVar2768, W, 1
0360  6EEF      	MOVWF INDF0

	*rtn_descriptor_size = descriptor_size;
0362  5134      	MOVF usb_get_de_00080_arg_rtn_d_00084+D'1', W, 1
0364  6EEA      	MOVWF FSR0H
0366  5133      	MOVF usb_get_de_00080_arg_rtn_d_00084, W, 1
0368  6EE9      	MOVWF FSR0L
036A  2AE9      	INCF FSR0L, F
036C  5137      	MOVF usb_get_de_00080_1_descrip_00086, W, 1
036E  6F39      	MOVWF CompTempVar2769, 1
0370  5138      	MOVF usb_get_de_00080_1_descrip_00086+D'1', W, 1
0372  6EEF      	MOVWF INDF0
0374  06E9      	DECF FSR0L, F
0376  5139      	MOVF CompTempVar2769, W, 1
0378  6EEF      	MOVWF INDF0

}
037A  0012      	RETURN


/*********************************************************************
 *                  Flowcode CAL ADC File
 *
 * File: PIC_CAL_ADC.c
 *
 * (c) 2011 Matrix Multimedia Ltd.
 * http://www.matrixmultimedia.com
 *
 * Software License Agreement
 *
 * The software supplied herewith by Matrix Multimedia Ltd (the
 * “Company”) for its Flowcode graphical programming language is
 * intended and supplied to you, the Company’s customer, for use
 * solely and exclusively on the Company's products. The software
 * is owned by the Company, and is protected under applicable
 * copyright laws. All rights are reserved. Any use in violation
 * of the foregoing restrictions may subject the user to criminal
 * sanctions under applicable laws, as well as to civil liability
 * for the breach of the terms and conditions of this licence.
 *
 * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
 * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
 * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * Changelog:
 *
 *  date  | by | description
 * -------+----+-----------------------------------------------------
 * 060911 | BR | Created
 * 200911 | BR | Updated to include all ADC type files
 * 110512 | BR | Fixed a bug with ADC type 13 and Vref+
 * 161012 | BR | Fixed a bug with ADC type 32 and 10 bit instead of 12 bit
 * 171212 | BR | Moved the code to begin the sample to allow for more optimised ADC readings
 * 020713 | LM | Standard API calls
 * 240414 | LM | Additions to support Touch via ADC
 * 040215 | LM | 16F726 fix modified so as to work with 16F1937
 * 040116 | LM | medelec35 fix Vref enable for ADC Type 7 (16F883, 16F884, 16F886, 16F887)
 */


//ADC Function Prototypes
void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge);
MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode);
void FC_CAL_ADC_Disable (void);
#ifdef MX_ADC_TOUCH
	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel);
#endif

//ADC Global Variables
MX_UINT8 old_tris, tris_mask;
MX_UINT8 * tris_reg;					//TRIS register pointer


// ADC Type 1 Supported Devices ************************************************************
// 16F818, 16F819, 16F873A, 16F874A, 16F876A, 16F877A,
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_1
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x0E;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#define MX_ADC_TOUCH_CASE(ADC, PORT, BIT)	\
			case (ADC):							\
			tris##PORT##.##BIT = 0;				\
			port##PORT##.##BIT = 1;				\
			adcon0 = (ADC << 3) | 0xC1;			\
			adcon0.0 = 0;						\
			port##PORT##.##BIT = 0;				\
			tris##PORT##.##BIT = 1;				\
			adcon1 = 0x80;						\
			adcon0.0 = 1;						\
			adcon0.2 = 1;						\
			while (adcon0.2);					\
			result = (adresh << 8) | adresl;	\
			break;

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		MX_UINT16 result = 0;
		MX_UINT8  temp = adcon1;
		adcon1 = 0x87;				// all ports digital

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
					MX_ADC_TOUCH_CASE(0, a, 0);
			#endif
			#ifdef MX_ADC_CHANNEL_1
					MX_ADC_TOUCH_CASE(1, a, 1);
			#endif
			#ifdef MX_ADC_CHANNEL_2
					MX_ADC_TOUCH_CASE(2, a, 2);
			#endif
			#ifdef MX_ADC_CHANNEL_3
					MX_ADC_TOUCH_CASE(3, a, 3);
			#endif
			#ifdef MX_ADC_CHANNEL_4
					MX_ADC_TOUCH_CASE(4, a, 5);
			#endif
			#ifdef MX_ADC_CHANNEL_5
					MX_ADC_TOUCH_CASE(5, e, 0);
			#endif
			#ifdef MX_ADC_CHANNEL_6
					MX_ADC_TOUCH_CASE(6, e, 1);
			#endif
			#ifdef MX_ADC_CHANNEL_7
					MX_ADC_TOUCH_CASE(7, e, 2);
			#endif
		}
		adcon1 = temp;
		return result;
	}
	#endif // MX_ADC_TOUCH

#endif


// ADC Type 2 Supported Devices ************************************************************
// 16F88
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_2
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG1);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel = 0x40;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH

#endif


// ADC Type 3 Supported Devices ************************************************************
// 16F616, 16F676, 16F677, 16F684, 16F685, 16F687, 16F688, 16F689, 16F690
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_3
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = ((Conv_Speed & 0x07) << 4);				//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 4 Supported Devices ************************************************************
// 16F737, 16F747, 16F767, 16F777
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_4
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					adcon1 = 0x01;
					break;
			#endif
		}

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6));					//turn ADC on
		adcon0 = adcon0 | ((Channel & 0x07) << 3);
		adcon0 = adcon0 | ((Channel & 0x08) >> 2);
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 5 Supported Devices ************************************************************
// 12F615, 12HV615, 12F675, 12F683
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_5
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					ansel = 0x08;
					break;
			#endif
		}

		ansel = ansel | ((Conv_Speed & 0x07) << 4);				//assign conversion speed

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref == 1)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 6 Supported Devices ************************************************************
// 16C72, 16C72A, 16CR72, 16F72, 16C73, 16C73A, 16C73B, 16F73, 16C74, 16C74A, 16C74B, 16F74,
// 16C76, 16F76, 16C77, 16F77, 16C716, 16F716
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_6
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x00;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 + 1;

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif



// ADC Type 7 Supported Devices ************************************************************
// 16F883, 16F884, 16F886, 16F887
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_7
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (13):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x20;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 2);	//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0x00;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0x00;
		#endif
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 8 Supported Devices ************************************************************
// 16F785
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_8
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel0 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel1 = 0x08;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel0 = 0x00;
		adcon0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 9 Supported Devices ************************************************************
// 16F913, 16F914, 16F916, 16F917, 16F946
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_9
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel = 0x80;
					break;
			#endif
		}

		adcon1 = ((Conv_Speed & 0x07) << 4);					//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 10 Supported Devices ***********************************************************
// 12C671, 12C672, 12CE673, 12CE674
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_10
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		tris_reg = &trisio;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					if (Vref == 0)
						adcon1 = 0x06;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adres << 2);								//10-bit ADC
		}
		else
			iRetVal = adres;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 11 Supported Devices ***********************************************************
// 16C717, 16C770, 16C771
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_11
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel = 0x20;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADFM);

		if (Vref != 0)											//assign VREF functionality
		{
			st_bit(adcon1, VCFG0);
			st_bit(adcon1, VCFG1);
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 12 Supported Devices ***********************************************************
// 18F6310, 18F6390, 18F6410, 18F6490, 18F6520, 18F6527, 18F6585, 18F66J60, 18F66J65,
// 18F6620, 18F6622, 18F6627, 18F6680, 18F67J60, 18F6720, 18F6722, 18F8310, 18F8390,
// 18F8410, 18F8490, 18F8520, 18F8527, 18F8585, 18F86J60, 18F86J65, 18F8620, 18F8622,
// 18F8627, 18F8680, 18F87J60, 18F8720, 18F8722, 18F96J60, 18F96J65, 18F97J60
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_12
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					adcon1 = 0x00;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 13 Supported Devices ***********************************************************
// 18F2220, 18F2221, 18F2320, 18F2321, 18F24J10, 18F2410, 18F2420, 18F2423, 18F2450,
// 18F2455, 18F2480, 18F25J10, 18F2510, 18F2515, 18F2520, 18F2523, 18F2525, 18F2550,
// 18F2580, 18F2585, 18F2610, 18F2620, 18F2680, 18F4220, 18F4221, 18F4320, 18F4321,
// 18F44J10, 18F4410, 18F4420, 18F4423, 18F4450, 18F4455, 18F4480, 18F45J10, 18F4510,
// 18F4515, 18F4520, 18F4523, 18F4525, 18F4550, 18F4580, 18F4585, 18F4610, 18F4620,
// 18F4680, 18F4682, 18F4685
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_13
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x02;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);								//BR changed from adcon0 05/12

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
		  #ifdef MX_ADC_BITS_12
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		  #else
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		  #endif
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 14 Supported Devices ***********************************************************
// 18F2331, 18F2431, 18F4331, 18F4431
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_14
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0x00;											//set up ADC conversion
		adcon2 = Conv_Speed & 0x07;
		adcon3 = 0x00;
		adchs = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon0 = 0x00;
					ansel0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon0 = 0x04;
					ansel0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon0 = 0x08;
					ansel0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon0 = 0x0C;
					ansel0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					adcon0 = 0x00;
					adchs = 0x01;
					ansel0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon0 = 0x04;
					adchs = 0x10;
					ansel0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x01;
					tris_reg = &trise;
					adcon0 = 0x08;
					adchs = 0x04;
					ansel0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x02;
					tris_reg = &trise;
					adcon0 = 0x0C;
					adchs = 0x40;
					ansel0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					adcon0 = 0x00;
					adchs = 0x02;
					ansel1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = adcon0 | 0x01;									//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ansel0 = 0x00;
		#ifdef ANSEL1
			ansel1 = 0x00;
		#endif
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 15 Supported Devices ***********************************************************
// 18F1220, 18F1320
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_15
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x7E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x7D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x7B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x77;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisb;
					adcon1 = 0x6F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisb;
					adcon1 = 0x5F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x10;
					tris_reg = &trisb;
					adcon1 = 0x3F;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x7f;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 16 Supported Devices ***********************************************************
// 18F242, 18F2439, 18F248, 18F252, 18F2539, 18F258, 18F442, 18F4439, 18F448, 18F452,
// 18F4539, 18F458
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_16
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x05;
					else
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x04;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref != 0)
						adcon1 = 0x03;
					else
						adcon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x0A;
					else
						adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref != 0)
						adcon1 = 0x01;
					else
						adcon1 = 0x00;
					break;
			#endif
		}

		if (Conv_Speed > 3)										//assign conversion speed
			st_bit(adcon1, ADCS2);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 17 Supported Devices ***********************************************************
// 18F1230, 18F1330
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_17
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;
		adcon1 = 0x00 | (0x01 << Channel);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x10;
					tris_reg = &trisa;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x40;
					tris_reg = &trisa;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 18 Supported Devices ***********************************************************
// 16F722, 16F723, 16F724, 16F726, 16F727, 16F1933, 16F1934, 16F1936, 16F1937, 16F1939
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_18

	#ifndef ADREF1
		#define ADREF1 ADPREF1
	#endif

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 | (Vref & 0x03);					//Mod to allow FVR as VREF

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			#ifdef ADRESH
				iRetVal = (adresh << 2);							//10-bit ADC
				iRetVal = iRetVal | (adresl >> 6);
			#else
				iRetVal = (adres << 2);							//10-bit ADC
			#endif
		}
		else
			#ifdef ADRESH
				iRetVal = adresh;									//8-bit ADC
            #else
				iRetVal = adres;
		    #endif

		adcon0 = adcon0 | 0x02;									//begin next conversion
		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#define MX_ADC_TOUCH_CASE(ADC, PORT, BIT)	\
			case (ADC):						\
			tris##PORT##.##BIT = 0;			\
			lat##PORT##.##BIT = 1;			\
			ansel##PORT##.##BIT = 1;		\
			adcon0 = (ADC << 2) | 1;		\
			adcon0.0 = 0;					\
			lat##PORT##.##BIT = 0;			\
			tris##PORT##.##BIT = 1;			\
			adcon0 = (ADC << 2) | 1;		\
			adcon0 = (ADC << 2) | 3;		\
			while (adcon0.1);				\
			ansel##PORT##.##BIT = 0;		\
			return (adresh << 8) | adresl;

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		adcon1 = 0xf0;						// Right justified result and set FRC clock mode

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
					MX_ADC_TOUCH_CASE(0, a, 0);
			#endif
			#ifdef MX_ADC_CHANNEL_1
					MX_ADC_TOUCH_CASE(1, a, 1);
			#endif
			#ifdef MX_ADC_CHANNEL_2
					MX_ADC_TOUCH_CASE(2, a, 2);
			#endif
			#ifdef MX_ADC_CHANNEL_3
					MX_ADC_TOUCH_CASE(3, a, 3);
			#endif
			#ifdef MX_ADC_CHANNEL_4
					MX_ADC_TOUCH_CASE(4, a, 5);
			#endif
			#ifdef MX_ADC_CHANNEL_5
					MX_ADC_TOUCH_CASE(5, e, 0);
			#endif
			#ifdef MX_ADC_CHANNEL_6
					MX_ADC_TOUCH_CASE(6, e, 1);
			#endif
			#ifdef MX_ADC_CHANNEL_7
					MX_ADC_TOUCH_CASE(7, e, 2);
			#endif
			#ifdef MX_ADC_CHANNEL_8
					MX_ADC_TOUCH_CASE(8, b, 2);
			#endif
			#ifdef MX_ADC_CHANNEL_9
					MX_ADC_TOUCH_CASE(9, b, 3);
			#endif
			#ifdef MX_ADC_CHANNEL_10
					MX_ADC_TOUCH_CASE(10, b, 1);
			#endif
			#ifdef MX_ADC_CHANNEL_11
					MX_ADC_TOUCH_CASE(11, b, 4);
			#endif
			#ifdef MX_ADC_CHANNEL_12
					MX_ADC_TOUCH_CASE(12, b, 0);
			#endif
			#ifdef MX_ADC_CHANNEL_13
					MX_ADC_TOUCH_CASE(13, b, 5);
			#endif
		}
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 19 Supported Devices ***********************************************************
// 18F13K50, 18F14K50, 18LF13K50, 18LF14K50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_19
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)

	{
		adcon1 = 0;
0E30  6AC1      	CLRF gbl_adcon1


		switch (Channel)
0E68            label126

		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
0E32  0E07      	MOVLW 0x07
0E34  63F4      	CPFSEQ FC_CAL_ADC_0004E_arg_Channel, 1
0E36  D001      	BRA	label123
0E38  D004      	BRA	label124
0E3A            label123
0E40  D009      	BRA	label125
0E42            label124

					tris_mask = 0x08;
0E42  0E08      	MOVLW 0x08
0E44  6FF1      	MOVWF gbl_tris_mask, 1

					tris_reg = &trisc;
0E46  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
0E48  6FD7      	MOVWF gbl_tris_reg+D'1', 1
0E4A  0E94      	MOVLW LOW(gbl_trisc+D'0')
0E4C  6FD6      	MOVWF gbl_tris_reg, 1

					adcon1 = 0x80;
0E4E  0E80      	MOVLW 0x80
0E50  6EC1      	MOVWF gbl_adcon1

					break;
0E52  D00A      	BRA	label126

			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
0E3A  0E08      	MOVLW 0x08
0E3C  63F4      	CPFSEQ FC_CAL_ADC_0004E_arg_Channel, 1
0E3E  D014      	BRA	label126
0E54            label125

					tris_mask = 0x40;
0E54  0E40      	MOVLW 0x40
0E56  6FF1      	MOVWF gbl_tris_mask, 1

					tris_reg = &trisc;
0E58  0E0F      	MOVLW HIGH(gbl_trisc+D'0')
0E5A  6FF8      	MOVWF CompTempVar2640, 1
0E5C  0E94      	MOVLW LOW(gbl_trisc+D'0')
0E5E  6FD6      	MOVWF gbl_tris_reg, 1
0E60  51F8      	MOVF CompTempVar2640, W, 1
0E62  6FD7      	MOVWF gbl_tris_reg+D'1', 1

					anselh = 0x01;
0E64  0E01      	MOVLW 0x01
0E66  6E7F      	MOVWF gbl_anselh

					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate
0E68  0E07      	MOVLW 0x07
0E6A  15F5      	ANDWF FC_CAL_ADC_0004E_arg_Conv_Speed, W, 1
0E6C  6EC0      	MOVWF gbl_adcon2


		if (Vref != 0)											//assign VREF functionality
0E6E  53F6      	MOVF FC_CAL_ADC_0004E_arg_Vref, F, 1
0E70  E00A      	BZ	label127
0E86            label127

			adcon1 = adcon1 | ((Vref & 0x03) << 2);				//Mod to allow FVR as VREF
0E72  0E03      	MOVLW 0x03
0E74  15F6      	ANDWF FC_CAL_ADC_0004E_arg_Vref, W, 1
0E76  6FF8      	MOVWF CompTempVar2641, 1
0E78  37F8      	RLCF CompTempVar2641, F, 1
0E7A  37F8      	RLCF CompTempVar2641, F, 1
0E7C  0EFC      	MOVLW 0xFC
0E7E  17F8      	ANDWF CompTempVar2641, F, 1
0E80  51F8      	MOVF CompTempVar2641, W, 1
0E82  10C1      	IORWF gbl_adcon1, W
0E84  6EC1      	MOVWF gbl_adcon1


		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
0E86  51D7      	MOVF gbl_tris_reg+D'1', W, 1
0E88  6EEA      	MOVWF FSR0H
0E8A  51D6      	MOVF gbl_tris_reg, W, 1
0E8C  6EE9      	MOVWF FSR0L
0E8E  50EF      	MOVF INDF0, W
0E90  6FF0      	MOVWF gbl_old_tris, 1

		*tris_reg = old_tris | tris_mask;
0E92  51F1      	MOVF gbl_tris_mask, W, 1
0E94  11F0      	IORWF gbl_old_tris, W, 1
0E96  6FF8      	MOVWF CompTempVar2643, 1
0E98  6EEF      	MOVWF INDF0

		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
0E9A  51F4      	MOVF FC_CAL_ADC_0004E_arg_Channel, W, 1
0E9C  6FF9      	MOVWF CompTempVar2645, 1
0E9E  37F9      	RLCF CompTempVar2645, F, 1
0EA0  37F9      	RLCF CompTempVar2645, F, 1
0EA2  0EFC      	MOVLW 0xFC
0EA4  17F9      	ANDWF CompTempVar2645, F, 1
0EA6  51F9      	MOVF CompTempVar2645, W, 1
0EA8  0901      	IORLW 0x01
0EAA  6FF8      	MOVWF CompTempVar2644, 1
0EAC  51F8      	MOVF CompTempVar2644, W, 1
0EAE  6EC2      	MOVWF gbl_adcon0

		delay_us(T_Charge);										//wait the acquisition time
0EB0  51F7      	MOVF FC_CAL_ADC_0004E_arg_T_Charge, W, 1
0EB2  6FF8      	MOVWF delay_us_00000_arg_del, 1
0EB4  EC06F000  	CALL delay_us_00000


		adcon0 = adcon0 | 0x02;									//begin next conversion
0EB8  0E02      	MOVLW 0x02
0EBA  10C2      	IORWF gbl_adcon0, W
0EBC  6EC2      	MOVWF gbl_adcon0

	}
0EBE  0012      	RETURN


	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)

	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
0DEC            label120
0DEC  B2C2      	BTFSC gbl_adcon0,1
0DEE  D7FE      	BRA	label120

		if (Sample_Mode)
0DF0  53F4      	MOVF FC_CAL_ADC_0004F_arg_Sample_Mode, F, 1
0DF2  E013      	BZ	label121
0E1A            label121

		{
			iRetVal = (adresh << 2);							//10-bit ADC
0DF4  50C4      	MOVF gbl_adresh, W
0DF6  6FF5      	MOVWF FC_CAL_ADC_0004F_1_iRetVal, 1
0DF8  6BF6      	CLRF FC_CAL_ADC_0004F_1_iRetVal+D'1', 1
0DFA  37F5      	RLCF FC_CAL_ADC_0004F_1_iRetVal, F, 1
0DFC  37F6      	RLCF FC_CAL_ADC_0004F_1_iRetVal+D'1', F, 1
0DFE  37F5      	RLCF FC_CAL_ADC_0004F_1_iRetVal, F, 1
0E00  37F6      	RLCF FC_CAL_ADC_0004F_1_iRetVal+D'1', F, 1
0E02  0EFC      	MOVLW 0xFC
0E04  17F5      	ANDWF FC_CAL_ADC_0004F_1_iRetVal, F, 1

			iRetVal = iRetVal | (adresl >> 6);
0E06  30C3      	RRCF gbl_adresl, W
0E08  6FF7      	MOVWF CompTempVar2649, 1
0E0A  33F7      	RRCF CompTempVar2649, F, 1
0E0C  3BF7      	SWAPF CompTempVar2649, F, 1
0E0E  0E03      	MOVLW 0x03
0E10  17F7      	ANDWF CompTempVar2649, F, 1
0E12  51F7      	MOVF CompTempVar2649, W, 1
0E14  13F5      	IORWF FC_CAL_ADC_0004F_1_iRetVal, F, 1
0E16  53F6      	MOVF FC_CAL_ADC_0004F_1_iRetVal+D'1', F, 1

		}
		else
0E18  D003      	BRA	label122
0E20            label122

			iRetVal = adresh;									//8-bit ADC
0E1A  50C4      	MOVF gbl_adresh, W
0E1C  6FF5      	MOVWF FC_CAL_ADC_0004F_1_iRetVal, 1
0E1E  6BF6      	CLRF FC_CAL_ADC_0004F_1_iRetVal+D'1', 1


		adcon0 = adcon0 | 0x02;									//begin next conversion
0E20  0E02      	MOVLW 0x02
0E22  10C2      	IORWF gbl_adcon0, W
0E24  6EC2      	MOVWF gbl_adcon0


		return (iRetVal);
0E26  51F5      	MOVF FC_CAL_ADC_0004F_1_iRetVal, W, 1
0E28  6FF7      	MOVWF CompTempVarRet2646, 1
0E2A  51F6      	MOVF FC_CAL_ADC_0004F_1_iRetVal+D'1', W, 1
0E2C  6FF8      	MOVWF CompTempVarRet2646+D'1', 1

	}
0E2E  0012      	RETURN


	void FC_CAL_ADC_Disable ()

	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
0EC0  0101      	MOVLB 0x01
0EC2  51D7      	MOVF gbl_tris_reg+D'1', W, 1
0EC4  6EEA      	MOVWF FSR0H
0EC6  51D6      	MOVF gbl_tris_reg, W, 1
0EC8  6EE9      	MOVWF FSR0L
0ECA  51F0      	MOVF gbl_old_tris, W, 1
0ECC  6EEF      	MOVWF INDF0

		ansel = 0;
0ECE  6A7E      	CLRF gbl_ansel

		adcon0 = 0x00;
0ED0  6AC2      	CLRF gbl_adcon0

		#ifdef ANSELH
			anselh = 0;
0ED2  6A7F      	CLRF gbl_anselh

		#endif
	}
0ED4  0012      	RETURN


	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 20 Supported Devices ***********************************************************
// 18F23K20, 18F24K20, 18F25K20, 18F26K20, 18F43K20, 18F44K20, 18F45K20, 18F16K20
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_20
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					adcon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					anselh = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					anselh = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					anselh = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					anselh = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					anselh = 0x10;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ansel = 0;
		adcon0 = 0x00;
		#ifdef ANSELH
			anselh = 0;
		#endif
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 21 Supported Devices ***********************************************************
// 18F2xJ11, 18F4xJ11
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_21
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0xFE;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0xFD;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0xFB;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0xF7;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0xEF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ancon0 = 0xDF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ancon0 = 0xBF;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ancon0 = 0x7F;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ancon1 = 0x1E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ancon1 = 0x1D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ancon1 = 0x1B;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ancon1 = 0x17;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ancon1 = 0x0F;
					break;
			#endif
		}

		adcon1 = Conv_Speed & 0x07;								//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0xFF;
		ancon1 = 0x1F;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 22 Supported Devices ***********************************************************
// 10F220, 10F222
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_22
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon0 = 0x00;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					asm("movf 1,w");
					asm("tris 6");
					adcon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					asm("movf 2,w");
					asm("tris 6");
					adcon0 = 0x84;
					break;
			#endif
		}

		adcon0 = adcon0 | 0x01;									//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;


		while (adcon0 & 0x02);
		if (Sample_Mode)
			iRetVal = (adres << 2);								//10-bit ADC
		else
			iRetVal = adres;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		adcon0 = 0x00;											//Reset ADC Registers
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 23 Supported Devices ***********************************************************
// 16F1826, 16F1827
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_23

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x40;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x80;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 | (Vref & 0x03);					//Mod to allow FVR as VREF

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 24 Supported Devices ***********************************************************
// 18F65J50, 18F66J50, 18F66J55, 18F67J50, 18F85J50, 18F86J50, 18F86J55, 18F87J50
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_24
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07);

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon0, VCFG0);

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0x00;
		ancon1 = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 25 Supported Devices ***********************************************************
// 18F66J93, 18F67J93, 18F86J93, 18F87J93, 18F66J90, 18F67J90, 18F86J90, 18F87J90
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_25
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					adcon1 = 0x0E;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					adcon1 = 0x0D;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					adcon1 = 0x0C;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					adcon1 = 0x0B;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					adcon1 = 0x0A;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					adcon1 = 0x09;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					adcon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					adcon1 = 0x07;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					adcon1 = 0x06;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					adcon1 = 0x03;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			st_bit(adcon1, VCFG0);

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x0f;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 26 Supported Devices ***********************************************************
// 12F1822, 16F1823, 16F1824, 16F1825, 16F1828, 16F1829
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_26

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x10;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x01;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x02;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 | (Vref & 0x03);					//Mod to allow FVR as VREF

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 27 Supported Devices ***********************************************************
// 16F1946, 16F1947
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_27

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = (Conv_Speed & 0x07) << 4;						//assign conversion rate

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ansel_reg = &anself;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (11):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (11):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (11):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (11):
					tris_mask = 0x01;
					tris_reg = &trisg;
					ansel_reg = &anselg;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 | (Vref & 0x03);					//Mod to allow FVR as VREF

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = *ansel_reg | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 28 Supported Devices ***********************************************************
// 18F65K22, 18F66K22, 18F67K22, 18F85K22, 18F86K22, 18F87K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_28
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x80;
					tris_reg = &trisf;
					ancon0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trisf;
					ancon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trisf;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x08;
					tris_reg = &trisf;
					ancon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisf;
					ancon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x20;
					tris_reg = &trisf;
					ancon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x40;
					tris_reg = &trisf;
					ancon1 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x10;
					tris_reg = &trish;
					ancon1 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trish;
					ancon1 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x40;
					tris_reg = &trish;
					ancon1 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x80;
					tris_reg = &trish;
					ancon1 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisg;
					ancon2 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x08;
					tris_reg = &trisg;
					ancon2 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x04;
					tris_reg = &trisg;
					ancon2 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x02;
					tris_reg = &trisg;
					ancon2 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x08;
					tris_reg = &trish;
					ancon2 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x04;
					tris_reg = &trish;
					ancon2 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x02;
					tris_reg = &trish;
					ancon2 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x01;
					tris_reg = &trish;
					ancon2 = 0x80;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 | ((Vref & 0x03) << 4);				//Mod to allow FVR as VREF

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon0 = 0x00;
		ancon0 = 0x00;
		#ifdef ANCON1
			ancon1 = 0x00;
		#endif
		#ifdef ANCON2
			ancon2 = 0x00;
		#endif
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 29 Supported Devices ***********************************************************
// 18F23K22, 18F24K22, 18F25K22, 18F26K22, 18F43K22, 18F44K22, 18F45K22, 18F46K22,
// 18LF23K22, 18LF24K22, 18LF25K22, 18LF26K22, 18LF43K22, 18LF44K22, 18LF45K22, 18LF46K22,
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_29

	MX_UINT8 * ansel_reg;					//ANSEL register pointer

	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon2 = Conv_Speed & 0x07;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ansel_reg = &ansela;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ansel_reg = &ansela;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ansel_reg = &ansele;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x04;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x08;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_11
				case (11):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_12
				case (12):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_13
				case (13):
					tris_mask = 0x20;
					tris_reg = &trisb;
					ansel_reg = &anselb;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_14
				case (14):
					tris_mask = 0x04;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_15
				case (15):
					tris_mask = 0x08;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_16
				case (16):
					tris_mask = 0x10;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_17
				case (17):
					tris_mask = 0x20;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_18
				case (18):
					tris_mask = 0x40;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_19
				case (19):
					tris_mask = 0x80;
					tris_reg = &trisc;
					ansel_reg = &anselc;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_20
				case (20):
					tris_mask = 0x01;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_21
				case (21):
					tris_mask = 0x02;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_22
				case (22):
					tris_mask = 0x04;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_23
				case (23):
					tris_mask = 0x08;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_24
				case (24):
					tris_mask = 0x10;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_25
				case (25):
					tris_mask = 0x20;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_26
				case (26):
					tris_mask = 0x40;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_27
				case (27):
					tris_mask = 0x80;
					tris_reg = &trisd;
					ansel_reg = &anseld;
					break;
			#endif
		}

		if (Vref != 0)											//assign VREF functionality
			adcon1 = adcon1 | ((Vref & 0x03) << 2);				//Mod to allow FVR as VREF

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		*ansel_reg = ansel_reg | tris_mask;

		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		*ansel_reg = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 30 Supported Devices ************************************************************
// 16F870, 16F871, 16F872, 16F873, 16F874, 16F876, 16F877
// *******************************************************************************************/

#ifdef MX_ADC_TYPE_30
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x0E;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					else
						adcon1 = 0x05;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					if (Vref == 0)
						adcon1 = 0x02;
					else
						adcon1 = 0x03;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x09;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					if (Vref == 0)
						adcon1 = 0x00;
					else
						adcon1 = 0x01;
					break;
			#endif
		}

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Conv_Speed << 6)) | (Channel << 3);	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x04;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x04);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 2);							//10-bit ADC
			iRetVal = iRetVal | (adresl >> 6);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x04;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		adcon1 = 0x07;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 31 Supported Devices ************************************************************
// 12F510, 16F506
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_31
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon0 = (0xC1 | (Conv_Speed << 4) | (Channel << 2));	//turn ADC on
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);

		iRetVal = adres;										//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


// ADC Type 32 Supported Devices ***********************************************************
// 18F2xK80, 18F4xK80, 18F6xK80
// *****************************************************************************************/

#ifdef MX_ADC_TYPE_32
	void FC_CAL_ADC_Enable (MX_UINT8 Channel, MX_UINT8 Conv_Speed, MX_UINT8 Vref, MX_UINT8 T_Charge)
	{
		adcon1 = 0;

		switch (Channel)
		{
			#ifdef MX_ADC_CHANNEL_0
				case (0):
					tris_mask = 0x01;
					tris_reg = &trisa;
					ancon0 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_1
				case (1):
					tris_mask = 0x02;
					tris_reg = &trisa;
					ancon0 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_2
				case (2):
					tris_mask = 0x04;
					tris_reg = &trisa;
					ancon0 = 0x04;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_3
				case (3):
					tris_mask = 0x08;
					tris_reg = &trisa;
					ancon0 = 0x08;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_4
				case (4):
					tris_mask = 0x20;
					tris_reg = &trisa;
					ancon0 = 0x10;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_5
				case (5):
					tris_mask = 0x01;
					tris_reg = &trise;
					ancon0 = 0x20;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_6
				case (6):
					tris_mask = 0x02;
					tris_reg = &trise;
					ancon0 = 0x40;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_7
				case (7):
					tris_mask = 0x04;
					tris_reg = &trise;
					ancon0 = 0x80;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_8
				case (8):
					tris_mask = 0x02;
					tris_reg = &trisb;
					ancon1 = 0x01;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_9
				case (9):
					tris_mask = 0x10;
					tris_reg = &trisb;
					ancon1 = 0x02;
					break;
			#endif
			#ifdef MX_ADC_CHANNEL_10
				case (10):
					tris_mask = 0x01;
					tris_reg = &trisb;
					ancon1 = 0x04;
					break;
			#endif
		}

		adcon2 = Conv_Speed & 0x07;								//assign conversion rate

		old_tris = *tris_reg;									//store old tris value, and set the i/o pin as an input
		*tris_reg = old_tris | tris_mask;
		adcon0 = (0x01 | (Channel << 2));						//turn ADC on

		if (Vref != 0)											//assign VREF functionality
		{
			adcon1 = adcon1 | ((Vref & 0x03) << 4);				//Mod to allow FVR as VREF
		}
		delay_us(T_Charge);										//wait the acquisition time

		adcon0 = adcon0 | 0x02;									//begin next conversion
	}

	MX_UINT16 FC_CAL_ADC_Sample (MX_UINT8 Sample_Mode)
	{
		MX_UINT16 iRetVal;

		while (adcon0 & 0x02);
		if (Sample_Mode)
		{
			iRetVal = (adresh << 4);							//12-bit ADC
			iRetVal = iRetVal | (adresl >> 4);
		}
		else
			iRetVal = adresh;									//8-bit ADC

		adcon0 = adcon0 | 0x02;									//begin next conversion

		return (iRetVal);
	}

	void FC_CAL_ADC_Disable ()
	{
		*tris_reg = old_tris;									//restore old tris value, and reset adc registers
		ancon0 = 0x00;
		ancon1 = 0x00;
		adcon0 = 0x00;
	}

	#ifdef MX_ADC_TOUCH

	#warning "ADC Touch not yet supported on this device"

	MX_UINT16 FC_CAL_ADC_Touch (MX_UINT8 Channel)
	{
		return 0;
	}
	#endif // MX_ADC_TOUCH
#endif


////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF47F008  	GOTO	_startup

0008  EF4AF009  	GOTO	interrupt
000C            delay_us_00000
000C            ; { delay_us ; function begin
000C            label1
000C  2FF8      	DECFSZ delay_us_00000_arg_del, F, 1
000E  D7FE      	BRA	label1
0010  0012      	RETURN
0012            ; } delay_us function end





































































04E6            memcpy8_00000
04E6            ; { memcpy8 ; function begin
04E6  5128      	MOVF memcpy8_00000_arg_dst, W, 1
04E8  6F2D      	MOVWF memcpy8_00000_1_dst2, 1
04EA  5129      	MOVF memcpy8_00000_arg_dst+D'1', W, 1
04EC  6F2E      	MOVWF memcpy8_00000_1_dst2+D'1', 1
04EE  512A      	MOVF memcpy8_00000_arg_src, W, 1
04F0  6F2F      	MOVWF memcpy8_00000_1_src2, 1
04F2  512B      	MOVF memcpy8_00000_arg_src+D'1', W, 1
04F4  6F30      	MOVWF memcpy8_00000_1_src2+D'1', 1
04F6            label43
04F6  0E00      	MOVLW 0x00
04F8  652C      	CPFSGT memcpy8_00000_arg_len, 1
04FA  D012      	BRA	label44
04FC  5130      	MOVF memcpy8_00000_1_src2+D'1', W, 1
04FE  6EEA      	MOVWF FSR0H
0500  512F      	MOVF memcpy8_00000_1_src2, W, 1
0502  6EE9      	MOVWF FSR0L
0504  4B2F      	INFSNZ memcpy8_00000_1_src2, F, 1
0506  2B30      	INCF memcpy8_00000_1_src2+D'1', F, 1
0508  50EF      	MOVF INDF0, W
050A  6F31      	MOVWF CompTempVar411, 1
050C  512E      	MOVF memcpy8_00000_1_dst2+D'1', W, 1
050E  6EEA      	MOVWF FSR0H
0510  512D      	MOVF memcpy8_00000_1_dst2, W, 1
0512  6EE9      	MOVWF FSR0L
0514  4B2D      	INFSNZ memcpy8_00000_1_dst2, F, 1
0516  2B2E      	INCF memcpy8_00000_1_dst2+D'1', F, 1
0518  5131      	MOVF CompTempVar411, W, 1
051A  6EEF      	MOVWF INDF0
051C  072C      	DECF memcpy8_00000_arg_len, F, 1
051E  D7EB      	BRA	label43
0520            label44
0520  5128      	MOVF memcpy8_00000_arg_dst, W, 1
0522  6F31      	MOVWF CompTempVarRet410, 1
0524  5129      	MOVF memcpy8_00000_arg_dst+D'1', W, 1
0526  6F32      	MOVWF CompTempVarRet410+D'1', 1
0528  0012      	RETURN
052A            ; } memcpy8 function end





















































































108E            _startup
108E  0ED5      	MOVLW 0xD5
1090  0100      	MOVLB 0x00
1092  6FFC      	MOVWF gbl_14_LSR, 1
1094  0EC4      	MOVLW 0xC4
1096  6FFD      	MOVWF gbl_14_LSR+D'1', 1
1098  0EBB      	MOVLW 0xBB
109A  6FFE      	MOVWF gbl_14_LSR+D'2', 1
109C  0EDC      	MOVLW 0xDC
109E  6FFF      	MOVWF gbl_14_LSR+D'3', 1
10A0  0101      	MOVLB 0x01
10A2  6BAE      	CLRF gbl_15_gbl_aSig, 1
10A4  6BAF      	CLRF gbl_15_gbl_aSig+D'1', 1
10A6  6BB0      	CLRF gbl_15_gbl_aSig+D'2', 1
10A8  6BB1      	CLRF gbl_15_gbl_aSig+D'3', 1
10AA  6BB2      	CLRF gbl_15_gbl_bSig, 1
10AC  6BB3      	CLRF gbl_15_gbl_bSig+D'1', 1
10AE  6BB4      	CLRF gbl_15_gbl_bSig+D'2', 1
10B0  6BB5      	CLRF gbl_15_gbl_bSig+D'3', 1
10B2  6BB6      	CLRF gbl_15_gbl_zSig, 1
10B4  6BB7      	CLRF gbl_15_gbl_zSig+D'1', 1
10B6  6BB8      	CLRF gbl_15_gbl_zSig+D'2', 1
10B8  6BB9      	CLRF gbl_15_gbl_zSig+D'3', 1
10BA  6BDA      	CLRF gbl_15_gbl_aExp, 1
10BC  6BDB      	CLRF gbl_15_gbl_bExp, 1
10BE  6BC6      	CLRF gbl_15_gbl_zExp, 1
10C0  6BC7      	CLRF gbl_15_gbl_zExp+D'1', 1
10C2  6BDC      	CLRF gbl_15_gbl_aSign, 1
10C4  6BDD      	CLRF gbl_15_gbl_bSign, 1
10C6  6BDE      	CLRF gbl_15_gbl_zSign, 1
10C8  6BDF      	CLRF gbl_15_gbl_zSigZero, 1
10CA  6BBA      	CLRF gbl_15_gbl_ret, 1
10CC  6BBB      	CLRF gbl_15_gbl_ret+D'1', 1
10CE  6BBC      	CLRF gbl_15_gbl_ret+D'2', 1
10D0  6BBD      	CLRF gbl_15_gbl_ret+D'3', 1
10D2  6BD8      	CLRF gbl_float_rounding_mode, 1
10D4  6BD9      	CLRF gbl_float_exception_flags, 1
10D6  6A5F      	CLRF gbl_float_detect_tininess

1290  EF02F008  	GOTO	main

300000  3238      	DW 0x3238
300002  1E1F      	DW 0x1E1F
300004  8808      	DW 0x8808
300006  C003      	DW 0xC003
300008  E003      	DW 0xE003
30000A  FFFF      	DW 0xFFFF
30000C  FFFF      	DW 0xFFFF
